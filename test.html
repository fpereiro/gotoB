<!DOCTYPE HTML>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="initial-scale=1">
      <title>goto–≤!</title>
   </head>
   <body>
      <noscript>Javascript is deactivated in your browser. Please activate it in order to use this page.</noscript>
      <script>
         var Time = {zero: new Date ().getTime ()};
      </script>
      <!-- TODO: change to CDN link -->
      <!--<script src="/json2.min.js"></script>-->
      <script src="gotoB.min.js"></script>
      <script>
         Time ['0: load'] = teishi.time () - Time.zero;
      </script>
      <script>
         (function () {

            // *** SETUP ***

            var dale = window.dale, teishi = window.teishi, lith = window.lith, c = window.c, B = window.B;

            var type = teishi.type, eq = teishi.eq, last = teishi.last, clog = teishi.clog;
            // TODO change after testing
            dale.clog = function () {}

            window.Data  = B.store.Data  = {};
            window.State = B.store.State = {};

            // *** TESTING ***

            var Test = function (tag, fun) {
               var error = fun ();
               if (! error) return B.say ('log', 'test OK', tag);
               B.say ('log', 'test error', error);
               B.eventlog ();
               throw new Error (tag + ': ' + error);
            }

            var Errorlist = [];

            window.onerror = function () {
               Errorlist.unshift (arguments);
            }

            // *** BASE LISTENERS ***

            Test ('initial setup', function () {
               if (! eq (dale.keys (B.listeners).sort (), ['add', 'error', 'rem', 'set'])) return 'Initial listeners mismatch.';
               // We use a setTimeout to wait until all the event listeners are set before we call the first we want to execute.
               setTimeout (function () {B.say ('test', 'log')}, 0);
            });

            // *** B.LOG ***

            B.listen ('test', 'log', {burn: true}, function (x) {

               B.say (x, 'verb1', 'a path', 'booyah');
               B.say (x, 'verb2', 'a path');

               Test ('log', function () {
                  if (B.log.length !== 4) return 'Invalid amount of log entries.';
                  if (! eq ({verb: B.log [0].verb, path: B.log [0].path}, {verb: 'log', path: ['test OK']})) return 'Invalid test OK log.';
                  if (! eq ({verb: B.log [1].verb, path: B.log [1].path}, {verb: 'test', path: ['log']})) return 'Invalid verb/path on first log item.';
                  if (B.log [2].from !== B.log [1].id || B.log [3].from !== B.log [1].id) return 'Invalid from value in second and third log entries.';
               });

               B.say (x, 'test', 'error');
            });

            B.listen ('test', 'error', {burn: true}, function (x) {

               Test ('show eventlog in case of error', function () {
                  B.say (x, 'error', 'test error');

                  if (! c ('#eventlog'))     return 'Eventlog was not shown when error happened.';
                  if (! c ('#errorwarning')) return 'Error warning was not shown when error happened.';

                  // Turn off the error listener until it is tested.
                  B.listeners.error.disabled = true;

                  B.say (x, 'test', 'data');
               });
            });

            // *** DATA FUNCTIONS ***

            B.listen ('test', 'data', {burn: true}, function (x) {

               Test ('data', function () {

                  var error;

                  // *** B.GET ***

                  error = dale.stopNot ([['ok', /notok/], [/notok/], ['ok', null], [null], ['ok', {}], [{}], ['ok', undefined], [undefined], ['ok', NaN], [NaN]], undefined, function (v, k) {
                     if (B.get.apply (null, v) !== undefined) return 'B.get accepted invalid path #' + (k + 1) + '-1.';
                     if (B.get (v)             !== undefined) return 'B.get accepted invalid path #' + (k + 1) + '-2.';
                  });
                  if (error) return error;

                  Data.items = ['hello'];
                  Data.item  = 'hello';

                  error = dale.stopNot ([[[], B.store], [['Data'], Data], [['Data', 'items'], Data.items], [['Data', 'items', 0], Data.items [0]], [['Data', 'item'], Data.item], [['foo'], undefined]], undefined, function (v, k) {
                     if (B.get.apply (null, v [0]) !== v [1]) return 'B.get returned invalid value #' + (k + 1) + '-1.';
                     if (B.get (v [0])             !== v [1]) return 'B.get returned invalid value #' + (k + 1) + '-2.';
                  });
                  if (error) return error;

                  delete Data.items;
                  delete Data.item;

                  // *** B.SET ***

                  error = dale.stopNot ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, {}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.set.apply (null, v) !== false) return 'B.set accepted invalid path #' + (k + 1) + '.';
                  });

                  if (error) return error;

                  if (B.set (x, [], 'a') !== false) return 'B.set accepted simple value with empty path #1.';
                  if (B.set ([], 'a')    !== false) return 'B.set accepted simple value with empty path #2.';
                  if (B.set (x, [], 333) !== false) return 'B.set accepted simple value with empty path #3.';
                  if (B.set ([], 333)    !== false) return 'B.set accepted simple value with empty path #4.';

                  error = dale.stopNot ([[['Data', 'items', 0], null], [['State', 'view'], 'main'], ['foo', 'bar'], [[], []], [[], {}], [[0], 1]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.set.apply (null, v) !== true)                 return 'B.set rejected valid arguments #'    + (k + 1) + '.';
                     if (B.get (last (v, 2)) !== last (v)) return 'B.set didn\'t set value correctly #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  error = dale.stopNot ([[['Data', 'items'], [0, 1, 2], {Data: {items: [0, 1, 2]}}], [['Data', 'key'], 'val', {Data: {items: [0, 1, 2], key: 'val'}}], [['Data', 0], 1, {Data: [1]}], [[], {Data: {}, State: {}}, {Data: {}, State: {}}]], undefined, function (v, k) {
                     k === 0 ? B.set (x, v [0], v [1]) : B.set (v [0], v [1]);
                     if (! eq (B.store, v [2])) return 'B.set overwrite error #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  // *** B.ADD ***

                  error = dale.stopNot ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, {}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.add.apply (null, v) !== false) return 'B.add accepted invalid path #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  error = dale.stopNot ([[['Data', 'items'], null, [null]], [['Data', 'items'], 0, [null, 0]], [['Data', 'items'], [null, 0]], [['Data', 'items'], 1, 2, [null, 0, 1, 2]]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.add.apply (null, v.slice (0, -1)) !== true) return 'B.add rejected valid arguments #'     + (k + 1) + '.';
                     if (! eq (B.get (v [k === 0 ? 1 : 0]), last (v)))        return 'B.add didn\'t add values correctly #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  if (B.add (x, 'Data', 0) !== false) return 'B.add didn\'t reject non-undefined target #1.';
                  if (B.add ('Data', 0) !== false)    return 'B.add didn\'t reject non-undefined target #2.';

                  B.add (x, 'foo');
                  if (! eq (B.get ('foo'), [])) return 'B.add didn\'t create array when receiving an undefined target and no elements to push #1.';
                  B.add ('foo');
                  if (! eq (B.get ('foo'), [])) return 'B.add didn\'t create array when receiving an undefined target and no elements to push #2.';

                  delete Data.items;
                  delete B.store.foo;

                  // *** B.REM ***

                  error = dale.stopNot ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, {}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.rem.apply (null, v) !== false) return 'B.rem accepted invalid path #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  B.set (['Data', 'items'], ['a', 'b', 'c']);

                  error = dale.stopNot ([[['Data', 'items'], 'a'], [['Data', 'items'], 0.1], ['Data', 0], [[], /foo/], ['Data', ['items', /foo/]]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.rem.apply (null, v) !== false) return 'B.rem allowed removing keys of the wrong type #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  error = dale.stopNot ([[['Data', 'foo'], 'a'], [[], 'foo'], ['Data', 'foo'], [['Data', 'items']], ['Data'], ['foo', /bar/], [['Data', 'items'], 5]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.rem.apply (null, v) !== true) return 'B.rem returned error when performing no-op #' + (k + 1) + '.';
                     if (! eq (B.store, {State: {}, Data: {items: ['a', 'b', 'c']}})) return 'B.rem modified store when performing no-op #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  var keys = [0, 2];

                  if (B.rem (['Data', 'items'], keys) !== true) return 'B.rem returned error when performing operation #1.';
                  if (! eq (B.get ('Data', 'items'), ['b']))    return 'B.rem didn\'t perform operation successfully #1.';
                  if (! eq (keys, [0, 2])) return 'B.rem modified keys array #1.';
                  if (B.rem ('Data', ['items']) !== true)       return 'B.rem returned error when performing operation #2.';
                  if (! eq (B.get ('Data'), {}))                return 'B.rem didn\'t perform operation successfully #2.';

                  B.set (['Data', 'items'], ['a', 'b', 'c']);

                  if (B.rem.apply (null, [['Data', 'items']].concat (keys)) !== true) return 'B.rem returned error when performing operation #3.';
                  if (! eq (B.get ('Data', 'items'), ['b']))    return 'B.rem didn\'t perform operation successfully #3.';
                  if (! eq (keys, [0, 2])) return 'B.rem modified keys array #2.';
                  if (B.rem ('Data', ['items']) !== true)       return 'B.rem returned error when performing operation #4.';
                  if (! eq (B.get ('Data'), {}))                return 'B.rem didn\'t perform operation successfully #4.';

                  if (B.rem ([], 'Data', 'State') !== true) return 'B.rem returned error when performing operation #5.';
                  if (! eq (B.get (), {}))                  return 'B.rem didn\'t perform operation successfully #5.';

                  B.set ([], {Data: {}, Store: {}});

                  // *** DATA EVENTS ***

                  var incrementOnChange = 0;

                  var listener = B.listen ('change', [], function () {
                     incrementOnChange++;
                  });

                  dale.go ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], function (v, k) {
                     B.say.apply (null, [x, 'set'].concat (v));
                  });

                  B.set (['Data', 'items'], ['a', 'b', 'c']);

                  dale.go ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN], [['Data', 'items', 0], 0]], function (v, k) {
                     B.say.apply (null, [x, 'add'].concat (v));
                  });

                  // The last add will trigger an event (because it has a valid path) but it won't trigger a change event.
                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event receiving invalid arguments #1.';
                  // The last add should trigger an error

                  if (incrementOnChange !== 0) return 'change event fired with a data event receiving invalid arguments #1.';

                  dale.go ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], function (v, k) {
                     B.say.apply (null, [x, 'rem'].concat (v));
                  });

                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event receiving invalid arguments #2.';

                  if (incrementOnChange !== 0) return 'change event fired with a data event receiving invalid arguments #2.';

                  // All these invalid invocations will trigger an event (because they have valid paths) but they won't trigger a change event.
                  dale.go ([[['Data', 'items'], 'a'], ['Data', 0], [[], /foo/], ['Data', ['items', /foo/]]], function (v, k) {
                     B.say.apply (null, [x, 'rem'].concat (v));
                  });

                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event receiving invalid arguments #3.';

                  if (incrementOnChange !== 0) return 'change event fired with a data event receiving invalid arguments #3.';

                  var llog = last (B.log);
                  if (! eq ({verb: llog.verb, path: llog.path, from: llog.from}, {verb: 'error', path: ['B.rem'], from: last (B.log, 2).id})) return 'error event not fired or fired improperly.';

                  // no-ops
                  dale.go ([['set', ['Data', 'items'], teishi.copy (B.get ('Data', 'items'))], ['set', [], teishi.copy (B.store)], ['set', 'foo', undefined], ['set', 'Data', B.get ('Data')], ['set', 'Data', teishi.copy (B.get ('Data'))], ['add', ['Data', 'items']], ['rem', ['Data', 'items'], 3, 4], ['rem', ['Data', 'items'], [3, 4]], ['rem', 'foo', 'bar'], ['rem', ['Data', 'items'], []], ['rem', ['Data', 'items']]], function (v, k) {
                     B.say.apply (null, k % 2 === 0 ? [x].concat (v) : v);
                  });

                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event performing a no-op.';

                  if (incrementOnChange !== 0) return 'change event fired with a data event performing a no-op.';

                  var error = dale.stopNot ([
                     ['set', [], {Data: {}, Store: {}}],
                     ['add', 'Array', 'whatever'],
                     ['rem', [], 'Array'],
                     ['add', ['Data', 'items'], 'one'],
                     ['add', ['Data', 'items'], 'two', 'three'],
                     ['add', ['Data', 'items'], 'four', 'five'],
                     ['rem', ['Data', 'items'], 3, 4],
                     ['rem', ['Data', 'items'], [0, 1, 2]],
                     ['add', ['Data', 'items'], undefined, null, {three: 3}, false],
                     ['set', 'Other', true],
                     ['rem', [], 'Other'],
                     ['set', ['Data', 'obj', 'last'], 'playboy'],
                     ['set', ['Data', 'items', 0, 0], 'beep'],
                     ['set', ['Data', 'null'], null],
                     ['rem', 'Data', 'obj', 'null']
                  ], undefined, function (test, k) {
                     var evid = B.say.apply (null, [x].concat (test)), eprefix = 'Test #' + (k + 1) + ': ', path = type (test [1]) === 'array' ? test [1] : [test [1]];

                     if (type (evid) !== 'string')      return eprefix + 'B.say didn\'t return event id.';
                     if (incrementOnChange !== (k + 1)) return eprefix + 'no change event triggered.';
                     var args = type (test [2]) === 'array' ? test [2] : test.slice (2);
                     if (test [0] === 'rem') {
                        if (dale.stop (args, true, function (key) {
                           return dale.keys (B.get (test [1])).indexOf (key) > -1;
                        })) return eprefix + 'rem didn\'t remove key.';
                        return;
                     }
                     if (dale.stop (path, true, function (pathitem, k2) {
                        var target = B.get (path.slice (0, k2));
                        if (type (target) !== (type (pathitem) === 'string' ? 'object' : 'array')) return true;
                     })) return eprefix + 'add/set didn\'t set parent target with the right type.';

                     if (test [0] === 'add' && type (B.get (path)) !== 'array') return eprefix + 'add didn\'t set the target type correctly.';
                     if (test [0] === 'set' && path.length) {
                        if (type (B.get (path.slice (0, -1))) !== (type (last (path)) === 'string' ? 'object' : 'array')) return eprefix + 'set didn\'t set the target type correctly.';
                     }
                     if (test [0] === 'add' && ! eq (B.get (path).slice (B.get (path).length - args.length), args)) return eprefix + 'add didn\'t add the value correctly.';
                     if (test [0] === 'set' && ! eq (B.get (test [1]), test [2])) return eprefix + 'set didn\'t set the value correctly.';
                  });

                  if (error) return error;

                  B.forget (listener);
               });

               // We update the references since we've re-assigned Data and State during the above tests.
               window.Data  = B.store.Data;
               window.State = B.store.State;

               B.say (x, 'test', 'B.ev');
            });

            // *** B.EV ***

            B.listen ('test', 'B.ev', {burn: true}, function (x) {

               Test ('B.str', function () {
                  if (B.str ([undefined, null, function () {return true}, false, /a/, 'a', 3, {a: '\'b', c: ['d"', NaN, Infinity], 'e-f': null}]) !== '[undefined, null, function () {return true}, false, /a/, "a", 3, {"a": "\'b", "c": ["d\\"", NaN, Infinity], "e-f": null}]') clog ('Warning: B.str setting list of values in a different way.', B.str ([undefined, null, function () {return true}, false, /a/, 'a', 3, {a: '\'b', c: ['d"', NaN, Infinity], 'e-f': null}]));
                  var test = eval (B.str ([undefined, null, function () {return true}, false, /a/, 'a', 3, {a: '\'b', c: ['d"', NaN, Infinity], 'e-f': null}]));

                  if (test [0] !== undefined) return 'B.str didn\'t set undefined.';
                  if (test [1] !== null) return 'B.str didn\'t set null.';
                  if (test [2] () !== true) return 'B.str didn\'t set function.';
                  if (test [3] !== false) return 'B.str didn\'t set function.';
                  if (type (test [4]) !== 'regex') return 'B.str didn\'t set regex.';
                  if (test [5] !== 'a') return 'B.str didn\'t set string.';
                  if (test [6] !== 3) return 'B.str didn\'t set number.';
                  if (! test [7] || test [7].a !== "'b" || test [7].c [0] !== 'd"' || type (test [7].c [1]) !== 'nan' || test [7].c [2] !== Infinity) return 'B.str didn\'t set object properly.';
               });

               Test ('B.ev validation', function () {
                  var error = dale.stopNot ([
                     [[/boo/],   'invalid verb'],
                     [[[/boo/]], 'invalid verb'],
                     [[null],   'invalid verb'],
                     [[[null]], 'invalid verb'],
                     [['boo'],   'no path'],
                     [[['boo']], 'no path'],
                     [['boo', 0.5],   'invalid path'],
                     [[['boo'], [null]], 'invalid path']
                  ], undefined, function (v, k) {
                     if (B.ev.apply (null, v [0]) !== false) return 'B.ev accepted invalid arguments: ' + v [1] + ' (#' + (k + 1) + ').';
                  });
                  if (error) return error;
               });

               Test ('B.ev valid input', function () {

                  var error = dale.stopNot ([
                     [[], ''],
                     [['a', 'b'], ' B.say ({"from": id}, "a", "b", this.value);'],
                     [['a', ['b']], ' B.say ({"from": id}, "a", ["b"], this.value);'],
                     [['a', 'b', 'c'], ' B.say ({"from": id}, "a", "b", "c");'],
                     [['a', 'b', undefined], ' B.say ({"from": id}, "a", "b", undefined);'],
                     [['a', 'b', null], ' B.say ({"from": id}, "a", "b", null);'],
                     [['a', 'b', null, true, NaN], ' B.say ({"from": id}, "a", "b", null, true, NaN);'],
                     [['a', 'b', /null/], ' B.say ({"from": id}, "a", "b", /null/);'],
                     [['a', 'b', {c: 'd'}], ' B.say ({"from": id}, "a", "b", {"c": "d"});'],
                     [['a', 'b', [{c: 'd'}]], ' B.say ({"from": id}, "a", "b", [{"c": "d"}]);'],
                     [['a', 'b', {raw: 'event'}], ' B.say ({"from": id}, "a", "b", event);'],
                     [['a', 'b', 'c', {raw: 'event'}], ' B.say ({"from": id}, "a", "b", "c", event);'],
                     [['a', 'b', 'c', {raw: 0}], ' B.say ({"from": id}, "a", "b", "c", {"raw": 0});'],
                     [['a', 'b', 'c', {raw: ['not', 'a', 'string']}], ' B.say ({"from": id}, "a", "b", "c", {"raw": ["not", "a", "string"]});'],
                     [['a', 'b', 'c', {raw: 'event', ignored: 'field'}], ' B.say ({"from": id}, "a", "b", "c", event);'],
                     [['a', 'b', '"two', {raw: 'event'}, {raw: 'this'}], ' B.say ({"from": id}, "a", "b", "\\"two", event, this);'],
                     [[['a', 'b'], ['c', 'd']], ' B.say ({"from": id}, "a", "b", this.value); B.say ({"from": id}, "c", "d", this.value);', true],
                     [[['a', 'b'], ['c', 'd', {raw: 'event.preventDefault'}]], ' B.say ({"from": id}, "a", "b", this.value); B.say ({"from": id}, "c", "d", event.preventDefault);', true]
                  ], undefined, function (v, k) {
                     var result = 'var id = B.say ("ev", event.type, B.evh (this));' + v [1];
                     if (B.ev.apply (null, v [0]) !== result) return 'B.ev error with valid arguments #' + (k + 1) + ': ' + B.ev.apply (null, v [0]) + ' Expected: ' + result;
                  });
                  if (error) return error;

               });

               Test ('B.ev + logs', function () {
                  c.fill ('body', lith.g ([
                     ['input', {'class': 'noclass', onchange: B.ev ('verb', 'path')}],
                  ]));

                  c ('.noclass') [0].value = 'hello';

                  try {
                     c.fire ('.noclass', 'change');
                  }
                  // IE<=8
                  catch (error) {
                     c.fire ('.noclass', 'onchange');
                  }

                  var logs = [last (B.log, 2), last (B.log)];

                  // IE<=8 adds other attributes to args, so we filter them out.
                  logs [0].args = dale.go (logs [0].args, function (v) {
                     return dale.obj (v, function (v2, k2) {
                        if (k2 === 'class') return [k2, v2];
                     });
                  });

                  if (! eq (logs [0], {t: logs [0].t, id: logs [0].id, from: undefined, verb: 'ev', path: ['change'], 'args': [{'class': 'noclass'}]})) return 'B.ev error: invalid logs #1.';
                  if (! eq (logs [1], {t: logs [1].t, id: logs [1].id, from: logs [0].id, verb: 'verb', path: ['path'], args: ['hello']})) return 'B.ev error: invalid logs #2.';
               });

               // Turn on again error handler
               //B.listeners.error.disabled = false;

               B.say (x, 'test', 'B.elem');

            });

         }) ();

      </script>
   </body>
</html>
