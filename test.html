<!DOCTYPE HTML>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="initial-scale=1">
      <title>goto–≤!</title>
   </head>
   <body>
      <noscript>Javascript is deactivated in your browser. Please activate it in order to use this page.</noscript>
      <script src="https://cdn.jsdelivr.net/gh/douglascrockford/JSON-js@aef828bfcd7d5efaa41270f831f8d27d5eef3845/json2.min.js"></script>
      <script>
         var time = Date.now ? function () {return Date.now ()} : function () {return new Date ().getTime ()};
         var Time = {zero: time ()}
      </script>
      <script src="gotoB.min.js"></script>
      <script>
         Time ['0: load'] = time () - Time.zero;
      </script>
      <script>
         (function () {

            // *** SETUP ***

            var dale = window.dale, teishi = window.teishi, lith = window.lith, c = window.c, B = window.B;

            var type = teishi.type, eq = teishi.eq, last = teishi.last, clog = teishi.clog;

            // We override dale.clog to avoid seeing a ton of alerts on old browsers.
            try {
               dale.clog = console.log.bind (console);
            }
            catch (error) {
               dale.clog = function () {
                  var output = dale.go (arguments, function (v) {return v === undefined ? 'undefined' : v}).join (' ');
                  if (window.console) window.console.log (output);
               }
            }

            window.Data  = B.store.Data  = {};
            window.State = B.store.State = {};

            // *** TESTING ***

            var Test = function (tag, fun) {
               var error = fun ();
               if (! error) return B.call ('log', 'test OK', tag);
               B.call ('log', 'test error', error);
               B.eventlog ();
               throw new Error (tag + ': ' + error);
            }

            var Errorlist = [];

            window.onerror = function () {
               Errorlist.unshift (arguments);
            }

            // *** BASE RESPONDERS ***

            Test ('initial setup', function () {
               if (! eq (dale.keys (B.responders).sort (), ['add', 'error', 'madd', 'mrem', 'mset', 'rem', 'set'])) return 'Initial responders mismatch.';
               // We use a setTimeout to wait until all the event responders are set before we call the first we want to execute.
               setTimeout (function () {B.call ('test', 'log')}, 0);
            });

            // *** B.LOG ***

            B.respond ('test', 'log', {burn: true}, function (x) {

               B.call (x, 'verb1', 'a path', 'booyah');
               B.call (x, 'verb2', 'a path');

               Test ('log', function () {
                  if (B.log.length !== 5) return 'Invalid amount of log entries.';
                  var mismatch = dale.stopNot ([
                     {from: undefined, id: 'E1', verb: 'log',   path: ['test OK'], args: ['initial setup']},
                     {from: undefined, id: 'E2', verb: 'test',  path: ['log'],     args: undefined},
                     {from: 'E2',      id: 'R8', verb: 'test',  path: ['log'],     args: undefined},
                     {from: 'R8/E2',   id: 'E3', verb: 'verb1', path: ['a path'],  args: ['booyah']},
                     {from: 'R8/E2',   id: 'E4', verb: 'verb2', path: ['a path'],  args: undefined}
                  ], undefined, function (v, k) {
                     var log = teishi.copy (B.log [k]);
                     delete log.t;
                     if (! eq (v, log)) return k + ': ' + B.str (log);
                  });
                  if (mismatch !== undefined) return 'Invalid log entry #' + (mismatch);
               });

               B.call (x, 'test', 'error');
            });
            B.respond ('test', 'error', {burn: true}, function (x) {

               Test ('show eventlog in case of error', function () {
                  B.call (x, 'error', 'test error');
                  if (! c ('#eventlog'))          return 'Eventlog was not shown when error happened.';

                  if (! c ('#eventlog-snackbar')) return 'Snackbar was not shown when error happened.';
               });

               // Turn off the error responder until it is tested.
               B.responders.error.disabled = true;

               B.call (x, 'test', 'data');

            });

            // *** DATA FUNCTIONS ***

            B.respond ('test', 'data', {burn: true}, function (x) {

               Test ('data', function () {

                  var error;

                  // *** B.GET ***

                  error = dale.stopNot ([['ok', /notok/], [/notok/], ['ok', null], [null], ['ok', {}], [{}], ['ok', undefined], [undefined], ['ok', NaN], [NaN]], undefined, function (v, k) {
                     if (B.get.apply (null, v) !== undefined) return 'B.get accepted invalid path #' + (k + 1) + '-1.';
                     if (B.get (v)             !== undefined) return 'B.get accepted invalid path #' + (k + 1) + '-2.';
                  });
                  if (error) return error;

                  Data.items = ['hello'];
                  Data.item  = 'hello';

                  error = dale.stopNot ([[[], B.store], [['Data'], Data], [['Data', 'items'], Data.items], [['Data', 'items', 0], Data.items [0]], [['Data', 'item'], Data.item], [['foo'], undefined]], undefined, function (v, k) {
                     if (B.get.apply (null, v [0]) !== v [1]) return 'B.get returned invalid value #' + (k + 1) + '-1.';
                     if (B.get (v [0])             !== v [1]) return 'B.get returned invalid value #' + (k + 1) + '-2.';
                  });
                  if (error) return error;

                  delete Data.items;
                  delete Data.item;

                  // *** B.SET ***

                  error = dale.stopNot ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, {}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.set.apply (null, v) !== false) return 'B.set accepted invalid path #' + (k + 1) + '.';
                  });

                  if (error) return error;

                  if (B.set (x, [], 'a') !== false) return 'B.set accepted simple value with empty path #1.';
                  if (B.set ([], 'a')    !== false) return 'B.set accepted simple value with empty path #2.';
                  if (B.set (x, [], 333) !== false) return 'B.set accepted simple value with empty path #3.';
                  if (B.set ([], 333)    !== false) return 'B.set accepted simple value with empty path #4.';

                  error = dale.stopNot ([[['Data', 'items', 0], null], [['State', 'view'], 'main'], ['foo', 'bar'], [[], []], [[], {}], [[0], 1]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.set.apply (null, v) !== true)                 return 'B.set rejected valid arguments #'    + (k + 1) + '.';
                     if (B.get (last (v, 2)) !== last (v)) return 'B.set didn\'t set value correctly #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  error = dale.stopNot ([[['Data', 'items'], [0, 1, 2], {Data: {items: [0, 1, 2]}}], [['Data', 'key'], 'val', {Data: {items: [0, 1, 2], key: 'val'}}], [['Data', 0], 1, {Data: [1]}], [[], {Data: {}, State: {}}, {Data: {}, State: {}}]], undefined, function (v, k) {
                     k === 0 ? B.set (x, v [0], v [1]) : B.set (v [0], v [1]);
                     if (! eq (B.store, v [2])) return 'B.set overwrite error #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  // *** B.ADD ***

                  error = dale.stopNot ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, {}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.add.apply (null, v) !== false) return 'B.add accepted invalid path #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  error = dale.stopNot ([[['Data', 'items'], null, [null]], [['Data', 'items'], 0, [null, 0]], [['Data', 'items'], [null, 0]], [['Data', 'items'], 1, 2, [null, 0, 1, 2]]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.add.apply (null, v.slice (0, -1)) !== true) return 'B.add rejected valid arguments #'     + (k + 1) + '.';
                     if (! eq (B.get (v [k === 0 ? 1 : 0]), last (v)))        return 'B.add didn\'t add values correctly #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  if (B.add (x, 'Data', 0) !== false) return 'B.add didn\'t reject non-undefined target #1.';
                  if (B.add ('Data', 0) !== false)    return 'B.add didn\'t reject non-undefined target #2.';

                  B.add (x, 'foo');
                  if (! eq (B.get ('foo'), [])) return 'B.add didn\'t create array when receiving an undefined target and no elements to push #1.';
                  B.add ('foo');
                  if (! eq (B.get ('foo'), [])) return 'B.add didn\'t create array when receiving an undefined target and no elements to push #2.';

                  delete Data.items;
                  delete B.store.foo;

                  // *** B.REM ***

                  error = dale.stopNot ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, {}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.rem.apply (null, v) !== false) return 'B.rem accepted invalid path #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  B.set (['Data', 'items'], ['a', 'b', 'c']);

                  error = dale.stopNot ([[['Data', 'items'], 'a'], [['Data', 'items'], 0.1], ['Data', 0], [[], /foo/], ['Data', ['items', /foo/]]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.rem.apply (null, v) !== false) return 'B.rem allowed removing keys of the wrong type #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  error = dale.stopNot ([[['Data', 'foo'], 'a'], [[], 'foo'], ['Data', 'foo'], [['Data', 'items']], ['Data'], ['foo', /bar/], [['Data', 'items'], 5]], undefined, function (v, k) {
                     if (k === 0) v.unshift (x);
                     if (B.rem.apply (null, v) !== true) return 'B.rem returned error when performing no-op #' + (k + 1) + '.';
                     if (! eq (B.store, {State: {}, Data: {items: ['a', 'b', 'c']}})) return 'B.rem modified store when performing no-op #' + (k + 1) + '.';
                  });
                  if (error) return error;

                  var keys = [0, 2];

                  if (B.rem (['Data', 'items'], keys) !== true) return 'B.rem returned error when performing operation #1.';
                  if (! eq (B.get ('Data', 'items'), ['b']))    return 'B.rem didn\'t perform operation successfully #1.';
                  if (! eq (keys, [0, 2])) return 'B.rem modified keys array #1.';
                  if (B.rem ('Data', ['items']) !== true)       return 'B.rem returned error when performing operation #2.';
                  if (! eq (B.get ('Data'), {}))                return 'B.rem didn\'t perform operation successfully #2.';

                  B.set (['Data', 'items'], ['a', 'b', 'c']);

                  if (B.rem.apply (null, [['Data', 'items']].concat (keys)) !== true) return 'B.rem returned error when performing operation #3.';
                  if (! eq (B.get ('Data', 'items'), ['b']))    return 'B.rem didn\'t perform operation successfully #3.';
                  if (! eq (keys, [0, 2])) return 'B.rem modified keys array #2.';
                  if (B.rem ('Data', ['items']) !== true)       return 'B.rem returned error when performing operation #4.';
                  if (! eq (B.get ('Data'), {}))                return 'B.rem didn\'t perform operation successfully #4.';

                  if (B.rem ([], 'Data', 'State') !== true) return 'B.rem returned error when performing operation #5.';
                  if (! eq (B.get (), {}))                  return 'B.rem didn\'t perform operation successfully #5.';

                  B.set ([], {Data: {}, Store: {}});

                  // *** DATA EVENTS ***

                  var incrementOnChange = 0;

                  var responder = B.respond ('change', [], {match: function (ev) {return ev.verb === 'change'}}, function () {
                     incrementOnChange++;
                  });

                  dale.go ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], function (v, k) {
                     B.call.apply (null, [x, 'set'].concat (v));
                  });

                  B.set (['Data', 'items'], ['a', 'b', 'c']);

                  dale.go ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN], [['Data', 'items', 0], 0]], function (v, k) {
                     B.call.apply (null, [x, 'add'].concat (v));
                  });

                  // The last add will trigger an event (because it has a valid path) but it won't trigger a change event.
                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event receiving invalid arguments #1.';
                  // The last add should trigger an error

                  if (incrementOnChange !== 0) return 'change event fired with a data event receiving invalid arguments #1.';

                  dale.go ([[/notok/, 'ok'], [/notok/], [null, 'ok'], [null], [{}, 'ok'], [{}], [undefined, 'ok'], [undefined], [NaN, 'ok'], [NaN]], function (v, k) {
                     B.call.apply (null, [x, 'rem'].concat (v));
                  });

                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event receiving invalid arguments #2.';

                  if (incrementOnChange !== 0) return 'change event fired with a data event receiving invalid arguments #2.';

                  // All these invalid invocations will trigger an event (because they have valid paths) but they won't trigger a change event.
                  dale.go ([[['Data', 'items'], 'a'], ['Data', 0], [[], /foo/], ['Data', ['items', /foo/]]], function (v, k) {
                     B.call.apply (null, [x, 'rem'].concat (v));
                  });

                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event receiving invalid arguments #3.';

                  if (incrementOnChange !== 0) return 'change event fired with a data event receiving invalid arguments #3.';

                  var llog = last (B.log);
                  if (! eq ({verb: llog.verb, path: llog.path, from: llog.from}, {verb: 'error', path: ['B.rem'], from: last (B.log, 2).id + '/' + last (B.log, 3).id})) return 'error event not fired or fired improperly.';

                  // no-ops
                  dale.go ([['set', ['Data', 'items'], teishi.copy (B.get ('Data', 'items'))], ['set', [], teishi.copy (B.store)], ['set', 'foo', undefined], ['set', 'Data', B.get ('Data')], ['set', 'Data', teishi.copy (B.get ('Data'))], ['add', ['Data', 'items']], ['rem', ['Data', 'items'], 3, 4], ['rem', ['Data', 'items'], [3, 4]], ['rem', 'foo', 'bar'], ['rem', ['Data', 'items'], []], ['rem', ['Data', 'items']]], function (v, k) {
                     B.call.apply (null, k % 2 === 0 ? [x].concat (v) : v);
                  });

                  if (dale.fil (B.log, undefined, function (log) {
                     if (log.verb === 'change') return log;
                  }).length) return 'change event logged with a data event performing a no-op.';

                  if (incrementOnChange !== 0) return 'change event fired with a data event performing a no-op.';

                  var changeCount = 0;

                  var error = dale.stopNot ([
                     ['set', [], {Data: {}, Store: {}}],
                     ['add', 'Array', 'whatever'],
                     ['rem', [], 'Array'],
                     ['add', ['Data', 'items'], 'one'],
                     ['add', ['Data', 'items'], 'two', 'three'],
                     ['add', ['Data', 'items'], 'four', 'five'],
                     ['rem', ['Data', 'items'], 3, 4],
                     ['rem', ['Data', 'items'], [0, 1, 2]],
                     ['add', ['Data', 'items'], undefined, null, {three: 3}, false],
                     ['set', 'Other', true],
                     ['rem', [], 'Other'],
                     ['set', ['Data', 'obj', 'last'], 'playboy'],
                     ['set', ['Data', 'items', 0, 0], 'beep'],
                     ['set', ['Data', 'null'], null],
                     ['rem', ['Data'], 'obj', 'null']
                  ], undefined, function (test, k) {
                     var evid = B.call.apply (null, [x].concat (test)), eprefix = 'Test #' + (k + 1) + ': ', path = type (test [1]) === 'array' ? test [1] : [test [1]];
                     changeCount += {6: 2, 7: 3, 14: 2} [k] || 1;

                     if (type (evid) !== 'string')      return eprefix + 'B.call didn\'t return event id.';
                     if (incrementOnChange !== changeCount) return eprefix + 'incorrect amount of change events triggered, expecting ' + changeCount + ', got ' + incrementOnChange;
                     var args = type (test [2]) === 'array' ? test [2] : test.slice (2);
                     if (test [0] === 'rem') {
                        var error;
                        dale.go ({2: 'Array', 6: [4, 3], 7: [2, 1, 0], 10: 'Other', 14: ['null', 'obj']} [k], function (v, k) {
                           if (! teishi.eq (test [1].concat (v), last (B.log, (k + 1) * 2).path)) error = 'Invalid path on change event triggered by rem, expecting ' + B.str (test [1].concat (v)) + ', got ' + B.str (last (B.log, (k + 1) * 2).path);
                        });
                        if (error) return error;
                        if (dale.stop (args, true, function (key) {
                           return dale.keys (B.get (test [1])).indexOf (key) > -1;
                        })) return eprefix + 'rem didn\'t remove key.';
                        return;
                     }
                     if (dale.stop (path, true, function (pathitem, k2) {
                        var target = B.get (path.slice (0, k2));
                        if (type (target) !== (type (pathitem) === 'string' ? 'object' : 'array')) return true;
                     })) return eprefix + 'add/set didn\'t set parent target with the right type.';

                     if (test [0] === 'add' && type (B.get (path)) !== 'array') return eprefix + 'add didn\'t set the target type correctly.';
                     if (test [0] === 'set' && path.length) {
                        if (type (B.get (path.slice (0, -1))) !== (type (last (path)) === 'string' ? 'object' : 'array')) return eprefix + 'set didn\'t set the target type correctly.';
                     }
                     if (test [0] === 'add' && ! eq (B.get (path).slice (B.get (path).length - args.length), args)) return eprefix + 'add didn\'t add the value correctly.';
                     if (test [0] === 'set' && ! eq (B.get (test [1]), test [2])) return eprefix + 'set didn\'t set the value correctly.';
                  });

                  if (error) return error;

                  // *** MUTE DATA EVENTS ***

                  var lastIncrementOnChange = incrementOnChange;

                  var error = dale.stopNot ([
                     ['mset', [], {Data: {}, Store: {}}],
                     ['madd', 'Array', 'whatever'],
                     ['mrem', [], 'Array'],
                     ['madd', ['Data', 'items'], 'one'],
                     ['madd', ['Data', 'items'], 'two', 'three'],
                     ['madd', ['Data', 'items'], 'four', 'five'],
                     ['mrem', ['Data', 'items'], 3, 4],
                     ['mrem', ['Data', 'items'], [0, 1, 2]],
                     ['madd', ['Data', 'items'], undefined, null, {three: 3}, false],
                     ['mset', 'Other', true],
                     ['mrem', [], 'Other'],
                     ['mset', ['Data', 'obj', 'last'], 'playboy'],
                     ['mset', ['Data', 'items', 0, 0], 'beep'],
                     ['mset', ['Data', 'null'], null],
                     ['mrem', 'Data', 'obj', 'null']
                  ], undefined, function (test, k) {
                     var evid = B.call.apply (null, [x].concat (test)), eprefix = 'Test #' + (k + 1) + ': ', path = type (test [1]) === 'array' ? test [1] : [test [1]];

                     if (type (evid) !== 'string')      return eprefix + 'B.call didn\'t return event id.';
                     if (incrementOnChange !== lastIncrementOnChange) return eprefix + ' change event triggered on mute event.';
                     var args = type (test [2]) === 'array' ? test [2] : test.slice (2);
                     if (test [0] === 'rem') {
                        if (dale.stop (args, true, function (key) {
                           return dale.keys (B.get (test [1])).indexOf (key) > -1;
                        })) return eprefix + 'rem didn\'t remove key.';
                        return;
                     }
                     if (dale.stop (path, true, function (pathitem, k2) {
                        var target = B.get (path.slice (0, k2));
                        if (type (target) !== (type (pathitem) === 'string' ? 'object' : 'array')) return true;
                     })) return eprefix + 'add/set didn\'t set parent target with the right type.';

                     if (test [0] === 'add' && type (B.get (path)) !== 'array') return eprefix + 'add didn\'t set the target type correctly.';
                     if (test [0] === 'set' && path.length) {
                        if (type (B.get (path.slice (0, -1))) !== (type (last (path)) === 'string' ? 'object' : 'array')) return eprefix + 'set didn\'t set the target type correctly.';
                     }
                     if (test [0] === 'add' && ! eq (B.get (path).slice (B.get (path).length - args.length), args)) return eprefix + 'add didn\'t add the value correctly.';
                     if (test [0] === 'set' && ! eq (B.get (test [1]), test [2])) return eprefix + 'set didn\'t set the value correctly.';
                  });

                  B.forget (responder);

                  // *** B.CHANGERESPONDER ***

                  var matches = [];

                  var responder2 = B.respond ('change', ['foo', 'bar'], {match: B.changeResponder}, function (x) {
                     matches.push (x.path);
                  });

                  B.call (x, 'set', [], teishi.copy (B.store));
                  if (matches.length !== 0) return 'B.changeResponder error #1';
                  B.call (x, 'set', ['foo', 'bar'], undefined);
                  if (matches.length !== 0) return 'B.changeResponder error #2';
                  B.call (x, 'set', ['foo', 'bar'], 2);
                  if (! eq (matches, [['foo', 'bar']])) return 'B.changeResponder error #3';
                  B.call (x, 'set', ['foo'], {bar: 2}, 2);
                  if (! eq (matches, [['foo', 'bar']])) return 'B.changeResponder error #4';
                  B.call (x, 'set', ['foo'], {bar: 3});
                  if (! eq (matches, [['foo', 'bar'], ['foo']])) return 'B.changeResponder error #5';
                  B.call (x, 'set', [], teishi.copy (B.store));
                  if (! eq (matches, [['foo', 'bar'], ['foo']])) return 'B.changeResponder error #6';
                  B.call (x, 'set', [], {foo: {bar: 2}});
                  if (! eq (matches, [['foo', 'bar'], ['foo'], []])) return 'B.changeResponder error #7';
                  B.call (x, 'set', ['foo', 'bar', 'yip'], 3);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip']])) return 'B.changeResponder error #8';
                  B.call (x, 'set', ['foo', 'bar', 'yip'], 3);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip']])) return 'B.changeResponder error #9';
                  B.call (x, 'set', ['foo', 'other'], 3);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip']])) return 'B.changeResponder error #10';
                  B.call (x, 'change', ['foo', 'bar']);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip'], ['foo', 'bar']])) return 'B.changeResponder error #11';
                  B.call (x, 'change', ['foo']);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip'], ['foo', 'bar'], ['foo']])) return 'B.changeResponder error #12';
                  B.call (x, 'change', ['foo', 'yip']);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip'], ['foo', 'bar'], ['foo']])) return 'B.changeResponder error #13';
                  B.call (x, 'change', ['yip']);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip'], ['foo', 'bar'], ['foo']])) return 'B.changeResponder error #14';
                  B.call (x, 'change', []);
                  if (! eq (matches, [['foo', 'bar'], ['foo'], [], ['foo', 'bar', 'yip'], ['foo', 'bar'], ['foo'], []])) return 'B.changeResponder error #15';

                  var currentValues  = [];
                  var previousValues = [];
                  var responder3 = B.respond ('change', ['esa', 'abuela'], function (x, currentValue, previousValue) {
                     currentValues.push  (currentValue);
                     previousValues.push (previousValue);
                  });
                  B.call (x, 'set', ['esa', 'abuela'], 1);
                  B.call (x, 'set', ['esa', 'abuela'], 2);
                  if (! eq (currentValues, [1, 2])) return 'change event not fired with currentValue.';
                  if (! eq (previousValues, [undefined, 1])) return 'change event not fired with previousValue.';

                  B.forget (responder2);
                  B.forget (responder3);

               });

               // We update the references since we've re-assigned Data and State during the above tests.
               B.store = {};
               window.Data  = B.store.Data  = {};
               window.State = B.store.State = {};

               B.call (x, 'test', 'B.ev');
            });

            // *** B.EV ***

            B.respond ('test', 'B.ev', {burn: true}, function (x) {

               Test ('B.str', function () {
                  if ([
                     '[undefined, null, function () {return true}, false, /a/, "a", 3, {"a": "\'b", "c": ["d\\"", NaN, Infinity], "e-f": null}]',
                     // Compatibility: Safari <= 8
                     '[undefined, null, function () {return true;}, false, /a/, "a", 3, {"a": "\'b", "c": ["d\\"", NaN, Infinity], "e-f": null}]',
                     // Compatibility: FF <= 16
                     '[undefined, null, function () {\n    return true;\n}, false, /a/, "a", 3, {"a": "\'b", "c": ["d\\"", NaN, Infinity], "e-f": null}]'
                  ].indexOf (B.str ([undefined, null, function () {return true}, false, /a/, 'a', 3, {a: '\'b', c: ['d"', NaN, Infinity], 'e-f': null}])) === -1) return 'Warning: B.str setting list of values in a different way: ' + B.str ([undefined, null, function () {return true}, false, /a/, 'a', 3, {a: '\'b', c: ['d"', NaN, Infinity], 'e-f': null}]);
                  var test = eval (B.str ([undefined, null, function () {return true}, false, /a/, 'a', 3, {a: '\'b', c: ['d"', NaN, Infinity], 'e-f': null}]));

                  if (test [0] !== undefined) return 'B.str didn\'t set undefined.';
                  if (test [1] !== null) return 'B.str didn\'t set null.';
                  if (test [2] () !== true) return 'B.str didn\'t set function.';
                  if (test [3] !== false) return 'B.str didn\'t set function.';
                  if (type (test [4]) !== 'regex') return 'B.str didn\'t set regex.';
                  if (test [5] !== 'a') return 'B.str didn\'t set string.';
                  if (test [6] !== 3) return 'B.str didn\'t set number.';
                  if (! test [7] || test [7].a !== "'b" || test [7].c [0] !== 'd"' || type (test [7].c [1]) !== 'nan' || test [7].c [2] !== Infinity) return 'B.str didn\'t set object properly.';
               });

               Test ('B.ev validation', function () {
                  var error = dale.stopNot ([
                     [[/boo/],   'invalid verb'],
                     [[[/boo/]], 'invalid verb'],
                     [[null],   'invalid verb'],
                     [[[null]], 'invalid verb'],
                     [['boo'],   'no path'],
                     [[['boo']], 'no path'],
                     [['boo', 0.5],   'invalid path'],
                     [[['boo'], [null]], 'invalid path']
                  ], undefined, function (v, k) {
                     if (B.ev.apply (null, v [0]) !== false) return 'B.ev accepted invalid arguments: ' + v [1] + ' (#' + (k + 1) + ').';
                  });
                  if (error) return error;
               });

               Test ('B.ev valid input', function () {
                  var defaultValue = ! B.internal.oldFF ? 'this.value' : 'this.value || (this.attributes.value ? this.attributes.value.nodeValue : "")';

                  var error = dale.stopNot ([
                     [[], ''],
                     [[[]], ''],
                     [[['a', 'b'], []], ' B.call ({"from": id}, "a", "b", ' + defaultValue + ');'],
                     [[[], ['a', 'b']], ' B.call ({"from": id}, "a", "b", ' + defaultValue + ');'],
                     [['a', 'b'], ' B.call ({"from": id}, "a", "b", ' + defaultValue + ');'],
                     [['a', ['b']], ' B.call ({"from": id}, "a", ["b"], ' + defaultValue + ');'],
                     [['a', 'b', 'c'], ' B.call ({"from": id}, "a", "b", "c");'],
                     [['a', 'b', undefined], ' B.call ({"from": id}, "a", "b", undefined);'],
                     [['a', 'b', null], ' B.call ({"from": id}, "a", "b", null);'],
                     [['a', 'b', null, true, NaN], ' B.call ({"from": id}, "a", "b", null, true, NaN);'],
                     [['a', 'b', /null/], ' B.call ({"from": id}, "a", "b", /null/);'],
                     [['a', 'b', {c: 'd'}], ' B.call ({"from": id}, "a", "b", {"c": "d"});'],
                     [['a', 'b', [{c: 'd'}]], ' B.call ({"from": id}, "a", "b", [{"c": "d"}]);'],
                     [['a', 'b', {raw: 'event'}], ' B.call ({"from": id}, "a", "b", event);'],
                     [['a', 'b', 'c', {raw: 'event'}], ' B.call ({"from": id}, "a", "b", "c", event);'],
                     [['a', 'b', 'c', {raw: 0}], ' B.call ({"from": id}, "a", "b", "c", {"raw": 0});'],
                     [['a', 'b', 'c', {raw: ['not', 'a', 'string']}], ' B.call ({"from": id}, "a", "b", "c", {"raw": ["not", "a", "string"]});'],
                     [['a', 'b', 'c', {raw: 'event', ignored: 'field'}], ' B.call ({"from": id}, "a", "b", "c", event);'],
                     [['a', 'b', '"two', {raw: 'event'}, {raw: 'this'}], ' B.call ({"from": id}, "a", "b", "\\"two", event, this);'],
                     [[['a', 'b'], ['c', 'd']], ' B.call ({"from": id}, "a", "b", ' + defaultValue + '); B.call ({"from": id}, "c", "d", ' + defaultValue + ');', true],
                     [[['a', 'b'], [], ['c', 'd']], ' B.call ({"from": id}, "a", "b", ' + defaultValue + '); B.call ({"from": id}, "c", "d", ' + defaultValue + ');', true],
                     [[['a', 'b'], ['c', 'd', {raw: 'event.preventDefault'}]], ' B.call ({"from": id}, "a", "b", ' + defaultValue + '); B.call ({"from": id}, "c", "d", event.preventDefault);', true]
                  ], undefined, function (v, k) {
                     var result = 'var id = B.call ("ev", event ? event.type : "undefined event", B.evh (this));' + v [1];
                     if (B.ev.apply (null, v [0]) !== result) return 'B.ev error with valid arguments #' + (k + 1) + ': ' + B.ev.apply (null, v [0]) + ' Expected: ' + result;
                  });
                  if (error) return error;

               });

               Test ('B.ev + logs', function () {
                  c.fill ('body', lith.g ([
                     ['input', {'class': 'noclass', onchange: B.ev ('verb', 'path')}],
                  ]));

                  c ('.noclass') [0].value = 'hello';

                  c.fire ('.noclass', 'change');

                  var logs = [last (B.log, 2), last (B.log)];

                  // Compatibility: IE<=8 adds other attributes to args, so we filter them out.
                  logs [0].args = dale.go (logs [0].args, function (v) {
                     return dale.obj (v, function (v2, k2) {
                        if (k2 === 'class') return [k2, v2];
                     });
                  });

                  if (! eq (logs [0], {t: logs [0].t, id: logs [0].id, from: undefined, verb: 'ev', path: ['change'], 'args': [{'class': 'noclass'}]})) return 'B.ev error: invalid logs #1.';
                  if (! eq (logs [1], {t: logs [1].t, id: logs [1].id, from: logs [0].id, verb: 'verb', path: ['path'], args: ['hello']})) return 'B.ev error: invalid logs #2.';
               });

               B.call (x, 'test', 'B.mount|unmount');

            });

            // *** B.MOUNT|UNMOUNT ***

            B.respond ('test', 'B.mount|unmount', {burn: true}, function (x) {

               Test ('B.validateLith', function () {
                  var error;
                  error = dale.stopNot ([
                     /a/,
                     ['p', 222, 222],
                     ['p', {}, 2, 3],
                     ['p', {'class': NaN}],
                     ['p', NaN],
                     [NaN],
                     ['style', ['not', 'a', 'litc']],
                     ['style', ['ok', {}, ['not', 'a', 'litc']]],
                     ['style', [
                        ['not', 'a', 'litc']
                     ]],
                     ['style', [
                        ['ok', {}],
                        ['not', 'a', 'litc']
                     ]],
                     ['style', [
                        ['ok', {}, ['not', 'a', 'litc']]
                     ]],
                     [1, 2, /bam/],
                     [1, 2, [/bam/], 4],
                     ['div', [
                        ['style', [2]],
                        ['p', 'something']
                     ]],
                     ['div', [
                        ['p', 'something'],
                        ['style', [
                           ['ok', {}],
                           ['not', 'a', 'litc']
                        ]]
                     ]],
                     ['div', [
                        ['p', 'something'],
                        ['style', [
                           ['ok', {}],
                           ['ok', {}, ['not', 'a', 'litc']]
                        ]]
                     ]],
                     ['div', [
                        ['LITERAL', ['nope']]
                     ]],
                     ['div', [
                        ['style', [
                           ['ok', {}],
                           ['LITERAL', ['nope']]
                        ]]
                     ]]
                  ], undefined, function (v) {
                     var validation = B.validateLith (v);
                     if (validation === 'Lith' || validation === 'Lithbag') return 'B.validateLith error with invalid input: ' + JSON.stringify (v) + ' ' + validation;
                  });
                  if (error) return error;

                  error = dale.stopNot ([
                     [true, ['br']],
                     [true, ['p', {id: 'p3', 'class': 'remark'}, 'This is a remark']],
                     [true, ['p', ['something']]],
                     [true, ['div', {id: 'container'}, ['p', {'class': 'remark'}, 'This is a remark']]],
                     [true, ['table', dale.go ([['A1', 'B1'], ['A2', 'B2']], function (v, k) {
                        return ['tr', {id: 'row' + (k + 1)}, dale.go (v, function (v2) {
                           return ['td', v2];
                        })];
                     })]],
                     [true, ['div', [
                        ['p'], ['p']
                     ]]],
                     [true, ['p', [
                        'Hola!', ['br']
                     ]]],
                     [false, [
                        ['p'], ['div']
                     ]],
                     [false, [
                        ['p'], [
                           ['div']
                        ]
                     ]],
                     [false, ['c', 'c']],
                     [false, [1, 2, ['bam'], 4]],
                     [true, (function () {
                        var dataset = [{id: 1, name: 'a'}, {id: 2, name: 'b'}];

                        function createRows (data) {
                           var output = [];
                           dale.go (data, function (v) {
                              output.push (['tr', [
                                 ['td', v.id],
                                 ['td', v.name],
                              ]]);
                           });
                           return output;
                        }

                        var table = ['table', [
                           ['tr', [
                              ['th', 'Id'],
                              ['th', 'Name']
                           ]],
                           createRows (dataset)
                        ]];

                        return table;
                     }) ()],
                     [true, ['div', [
                        ['p', 'Hi'],
                        ['LITERAL', '<p>Hello!</p>']
                     ]]],
                     [true, ['script', {src: 'scripts.js', charset: 'utf-8'}]],
                     [true, ['style', ['span.action', {color: 'blue'}]]],
                     [true, ['style', lith.css.g (['span.action', {color: 'blue'}])]],
                     [true, ['style', ['a', ['a', {}, ['a']]]]]
                  ], undefined, function (v) {
                     var validation = B.validateLith (v [1]);
                     if (v [0]   && validation !== 'Lith')    return 'B.validateLith error with valid input: ' + JSON.stringify (v [1]) + ' ' + validation;
                     if (! v [0] && validation !== 'Lithbag') return 'B.validateLith error with valid input: ' + JSON.stringify (v [1]) + ' ' + validation;
                  });
                  if (error) return error;
               });

               var f = function (a) {
                  return function () {return a}
               }

               Test ('B.mount & B.unmount invalid input', function () {
                  if (B.mount ('p') !== false) return 'B.mount accepted invalid target #1.';
                  if (B.mount ('#a p') !== false) return 'B.mount accepted invalid target #2.';
                  if (B.mount (22) !== false) return 'B.mount accepted invalid target #3.';
                  if (B.mount ({}) !== false) return 'B.mount accepted invalid target #4.';
                  if (B.mount ('body>p', f ([])) !== false) return 'B.mount accepted invalid target #5.';
                  if (B.mount ('body', f (/a/)) !== false) return 'B.mount accepted invalid elem #1.';
                  if (B.mount ('body', f ({})) !== false) return 'B.mount accepted invalid elem #2.';
                  if (B.mount ('body', f (null)) !== false) return 'B.mount accepted invalid elem #3.';
                  if (B.mount ('body', f (['a', 'c', 'd'])) !== false) return 'B.mount accepted invalid elem #4.';
                  if (B.mount ('body', ['div']) !== false) return 'B.mount accepted invalid elem #5.';
                  if (B.mount ('#nosuch', []) !== false) return 'B.mount accepted non-existing target.';

                  if (B.unmount ('p') !== false) return 'B.unmount accepted invalid target #1.';
                  if (B.unmount ('#a p') !== false) return 'B.unmount accepted invalid target #2.';
                  if (B.unmount (22) !== false) return 'B.unmount accepted invalid target #3.';
                  if (B.unmount ({}) !== false) return 'B.unmount accepted invalid target #4.';
                  if (B.unmount ('body>p') !== false) return 'B.unmount accepted invalid target #5.';
                  if (B.unmount ('#nosuch', []) !== false) return 'B.unmount accepted non-existing target.';
               });

               Test ('B.mount & B.unmount valid', function () {

                  c.empty ('body');

                  B.mount ('body', function () {
                     return ['div', {id: 'first'}, 'a'];
                  });

                  if (! c ('body div#second')) return 'B.mount didn\'t place element.';

                  B.mount ('body', function () {
                     return ['div', {id: 'second'}, 'b'];
                  });

                  if (! eq (c.get ('div', 'id'), [{id: 'first'}, {id: 'second'}])) return 'B.mount didn\'t put element at the bottom of the target.';

                  B.mount ('#first', function () {
                     return ['div', {id: 'third'}, 'c'];
                  });

                  if ([
                     '<div id="first">a<div id="third">c</div></div><div id="second">b</div>',
                     // Compatibility: IE<=8 removes the quotes of id, uppercases the tags and adds \r\n
                     '<DIV id=first>a\r\n<DIV id=third>c</DIV></DIV>\r\n<DIV id=second>b</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'B.mount didn\'t mount element inside element.';

                  c.empty ('#first');

                  B.mount ('#first', f (['lith', 'bag']));

                  if (c ('#first').innerHTML !== 'lithbag') return 'B.mount didn\'t mount lithbag.';

                  B.unmount ('body');

                  if (document.body.innerHTML !== '') return 'B.unmount didn\'t clear target.';

                  B.respond ('a', 'b', {id: B.B + 1}, function () {});
                  B.respond ('a', 'b', {id: B.B + 2}, function () {});
                  B.mount ('body', function () {
                     return ['div', {id: B.B + 1}, 'id="' + B.B + 2 + '"'];
                  });

                  B.unmount ('body');
                  if (B.responders [B.B + 1]) return 'B.unmount didn\'t remove event responder that corresponded to an element id.';
                  if (! B.responders [B.B + 2]) return 'B.unmount removed responder that didn\'t correspond to an element id.';
                  B.forget (B.B + 2);

                  if (B.mount ('body', function () {}) !== undefined) return 'B.mount didn\'t accept empty element.';
               });

               B.call (x, 'ok', 'ok');

               B.call (x, 'test', 'B.prediff');
            });

            // *** B.PREDIFF ***

            B.respond ('test', 'B.prediff', {burn: true}, function (x) {

               Test ('B.prediff', function () {
                  var error = dale.stopNot ([
                     [['a'], ['O a', 'C a']],
                     [['a', {}], ['O a {}', 'C a']],
                     [['table'], B.internal.olderIE ? ['O table', 'O tbody', 'C tbody', 'C table'] : ['O table', 'C table']],
                     [['table', ['tr']], ['O table', 'O tbody', 'O tr', 'C tr', 'C tbody', 'C table']],
                     [['table', ['tr', ['td', ['table', ['tr']]]]], ['O table', 'O tbody', 'O tr', 'O td', 'O table', 'O tbody', 'O tr', 'C tr', 'C tbody', 'C table', 'C td', 'C tr', 'C tbody', 'C table']],
                     [['table', ['thead', ['tr']]], B.internal.olderIE ? ['O table', 'O thead', 'O tr', 'C tr', 'C thead', 'O tbody', 'C tbody', 'C table'] : ['O table', 'O thead', 'O tr', 'C tr', 'C thead', 'C table']],
                     [['table', [['thead', ['tr']], ['tr']]], ['O table', 'O thead', 'O tr', 'C tr', 'C thead', 'O tbody', 'O tr', 'C tr', 'C tbody', 'C table']],
                     [['a', undefined], ['O a', 'C a']],
                     [['a', ''], ['O a', 'C a']],
                     [['a', ['']], ['O a', 'C a']],
                     [['a', 'a'], ['O a', 'L a', 'C a']],
                     [['a', ['z', '']], ['O a', 'L z', 'C a']],
                     [['a', ['z', 'b']], ['O a', 'L zb', 'C a']],
                     [['a', ['z', ' b']], ['O a', 'L z b', 'C a']],
                     [['a', [1, 'z', ' b']], ['O a', 'L 1z b', 'C a']],
                     [['a', [[[['z']]], 'b']], ['O a', 'L zb', 'C a']],
                     [['a', {b: 'c'}], ['O a {"b":"c"}', 'C a']],
                     [['a', {b: null}], ['O a {}', 'C a']],
                     [['a', {b: false}], ['O a {}', 'C a']],
                     [['a', {b: ''}], ['O a {}', 'C a']],
                     [['a', {a: '', b: 'c', d: null, e: false, f: 'g'}], ['O a {"b":"c","f":"g"}', 'C a']],
                     [['a', {b: ''}], ['O a {}', 'C a']],
                     [['a', {b: undefined}], ['O a {}', 'C a']],
                     [['a', {b: 0}], ['O a {"b":0}', 'C a']],
                     [['a', {b: 'c'}, 'd'], ['O a {"b":"c"}', 'L d', 'C a']],
                     [['a', {b: 'c'}, ['d', 'e']], ['O a {"b":"c"}', 'L de', 'C a']],
                     [['a', ['LITERAL', '<svg></svg>']], ['O a', 'L <svg></svg>', 'C a']],
                     [['a', {opaque: true}, ['LITERAL', '<svg></svg>']], ['P 19 a {"opaque":true} <svg></svg>']],
                     [['a', {opaque: true}, '<svg></svg>'], ['P 19 a {"opaque":true} &lt;svg&gt;&lt;/svg&gt;']],
                     [['a', '<svg></svg>'], ['O a', 'L &lt;svg&gt;&lt;/svg&gt;', 'C a']],
                     [['div', [['a', {href: 'c'}], ['p', 2]]], ['O div', 'O a {"href":"c"}', 'C a', 'O p', 'L 2', 'C p', 'C div']],
                     [['style', ['div', {margin: 0}]], ['O style', 'L div{margin:0;}', 'C style']]
                  ], undefined, function (v, k) {
                     if (! eq (B.prediff (v [0]), v [1])) return 'B.prediff mismatch: ' + (k + 1) + ' ' + JSON.stringify (v) + '   ' + B.prediff (v [0]);
                  });

                  if (error) return error;

                  B.responders [B.B + 1000] = {elem: ['a', {id: B.B + 1000}, 'z']};

                  if (
                     ! eq (B.prediff (['a', {id: B.B + 1000}, 'u']), ['O a {"id":"' + B.B + 1000 + '"}', 'L u', 'C a']) &&
                     // Compatibility: We use `\u0432` instead of `B.B` because of IE8 (but not IE6-7!)
                     ! eq (B.prediff (['a', {id: B.B + 1000}, 'u']), ['O a {"id":"\\u0432' + 1000 + '"}', 'L u', 'C a'])
                  ) return 'Mismatch when prediffing up top-level reactive view: ' + B.prediff (['a', {id: B.B + 1000}, 'u']);

                  if (
                     ! eq (['O div', 'O a {"id":"' + B.B + 1000 + '"}', 'L z', 'C a', 'C div'], B.prediff (['div', ['a', {id: B.B + 1000}, 'u']])) &&
                     // Compatibility: We use `\u0432` instead of `B.B` because of IE8 (but not IE6-7!)
                     ! eq (['O div', 'O a {"id":"\\u0432' + 1000 + '"}', 'L z', 'C a', 'C div'], B.prediff (['div', ['a', {id: B.B + 1000}, 'u']]))
                  ) return 'Mismatch when looking up nested reactive view.';

                  B.forget (B.B + 1000);
               });

               B.call (x, 'test', 'B.view');
            });

            // *** B.VIEW ***

            B.respond ('test', 'B.view', {burn: true}, function (x) {

               Test ('B.redraw', function () {
                  var noElement = B.redraw ({}, 'nosuch');
                  var lastLog = last (B.log);
                  if (noElement !== false || ! eq ({verb: 'error', path: ['B.redraw'], error: 'Attempt to redraw dangling element.'}, {verb: lastLog.verb, path: lastLog.path, error: lastLog.args [0]})) return 'No such element error wasn\'t reported properly.';
                  if (B.internal.redrawing !== true) return 'B.redraw didn\'t set redrawinf flag #1.';
                  B.internal.redrawing = false;

                  var el = document.createElement ('div');
                  el.id = 'abc';

                  var danglingElement = B.redraw ({}, 'abc');
                  lastLog = last (B.log);
                  if (noElement !== false || ! eq ({verb: 'error', path: ['B.redraw'], error: 'Attempt to redraw dangling element.'}, {verb: lastLog.verb, path: lastLog.path, error: lastLog.args [0]})) return 'Dangling element error wasn\'t reported properly.';

                  if (B.internal.redrawing !== true) return 'B.redraw didn\'t set redrawinf flag #2.';
                  B.internal.redrawing = false;

                  // Error reporting of B.applyDiff errors is not tested here.
               });

               var logLength = B.log.length;

               Test ('B.view invalid inputs', function () {
                  var error = dale.stopNot ([
                     {path: undefined, fun: function () {}},
                     {path: / /, fun: function () {}},
                     {path: function () {}, fun: function () {}},
                     {path: [null], fun: function () {}},
                     {path: 'a', fun: undefined},
                     {path: 'a', fun: / /},
                     {path: 'a', fun: null},
                     {path: 'a', fun: ''},
                     {path: 'a', fun: []}
                  ], undefined, function (args, k) {
                     if (B.view (args.path, args.fun) !== false) return 'B.view - invalid arguments accepted as valid: ' + B.str (args);
                     if (B.log.length !== logLength + k + 1) return 'Error not reported: ' + B.str (args);
                     var lastLog = last (B.log);
                     if (lastLog.verb !== 'error' || lastLog.path [0] !== 'B.view' || ! lastLog.args.length || type (lastLog.args [0]) !== 'string') return 'Error reported incorrectly: ' + B.str (args);
                     if (! lastLog.args [0].match (k <= 3 ? 'Invalid path' : 'Validation error:')) return 'Invalid error message: ' + B.str (args);
                     if (k > 3 && ! lastLog.args [1].match ('fun passed to B.view should')) return 'Invalid error message: ' + B.str (args);
                  });
                  if (error) return error;

                  if (B.internal.count !== 1) return 'Invalid invocation to B.view incremented B.internal.count.';

               });

               logLength = B.log.length;

               Test ('B.view invalid vfun outputs', function () {
                  var error = dale.stopNot ([
                     {path: [1], fun: function () {}},
                     {path: [2], fun: function () {return 'a'}},
                     {path: [3], fun: function () {return [377, 'a']}},
                     {path: [4], fun: function () {return /boo/}},
                     {path: [5], fun: function () {return null}},
                     {path: [6], fun: function () {return ['div.green', {color: 'green'}]}},
                     {path: [7], fun: function () {return ['div', {id: 'a'}]}}
                  ], undefined, function (args, k) {
                     if (B.view (args.path, args.fun) !== false) return 'B.view - invalid arguments accepted as valid: ' + B.str (args);
                     if (B.log.length !== logLength + k + 1) return 'Error not reported: ' + B.str (args);
                     var lastLog = last (B.log);
                     if (lastLog.verb !== 'error' || lastLog.path [0] !== 'B.view' || ! lastLog.args.length || type (lastLog.args [0]) !== 'string') return 'Error reported incorrectly: ' + B.str (args);
                     if (! lastLog.args [0].match (/View function at path/)) return 'Invalid error message: ' + B.str (args);
                     if (! lastLog.args [2].match (/must return a lith element/)) return 'Invalid error message: ' + B.str (args);
                     if (! B.responders [B.B + (k + 1)]) return 'Responder not set: ' + B.str (args);
                     if (B.responders [B.B + (k + 1)].path.length !== 0) return 'Responder not set with empty path.';
                     B.forget (B.B + (k + 1));
                  });
                  if (error) return error;

                  B.internal.count = 1;
               });

               // Turn on again error handler
               B.responders.error.disabled = false;

               Test ('B.view valid inputs, non-nested', function () {

                  // INITIAL SETUP

                  B.call (x, 'set', ['Data', 'view'], ['div']);

                  B.mount ('body', function () {
                     return B.view (['Data', 'view'], function (view) {
                        return view;
                     });
                  });

                  if ([
                     '<div id="–≤1" path="Data:view"></div>',
                     // Compatibility: IE<=8 removes the quotes around id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #1: ' + document.body.innerHTML;

                  var responder = B.responders [B.B + 1];
                  if (responder.verb !== 'change') return 'Invalid change #1.';
                  if (responder.path.length !== 0) return 'Invalid path #1.';
                  if (responder.priority !== -1) return 'Invalid priority #1.';
                  if (eq (responder.elem, B.get ('Data', 'view'))) return 'Store was modified by vfun #1.';
                  if (! eq (responder.elem, ['div', {id: B.B + 1, path: 'Data:view'}])) return 'Invalid elem #1.';
                  if (responder.children.length !== 0) return 'Invalid children #1.';

                  var DOMElement = c ('#' + B.B + 1);
                  if (c.get ('#' + B.B + 1, 'path').path !== 'Data:view') return 'Invalid path in DOM #1.';

                  // ADD CLASS

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': 'hello'}]);

                  if (c ('#' + B.B + 1) !== DOMElement) return 'DOM element not recycled #2.';
                  if (c.get ('#' + B.B + 1, 'path').path !== 'Data:view') return 'Invalid path in DOM #2.';
                  if (c.get ('.hello').length !== 1) return 'Class not applied #2.';

                  if ([
                     '<div id="–≤1" path="Data:view" class="hello"></div>',
                     // Compatibility: IE10-11, FF<=48 put the class first
                     '<div class="hello" id="–≤1" path="Data:view"></div>',
                     // Compatibility: IE9 puts the class in the middle
                     '<div id="–≤1" class="hello" path="Data:view"></div>',
                     // Compatibility: IE<=8 puts the class in the middle, removes the quotes around id & class and uppercases the tag name
                     '<DIV id=–≤1 class=hello path="Data:view"></DIV>',
                     // Compatibility: IE<=7 puts the class at the beginning
                     '<DIV class=hello id=–≤1 path="Data:view"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #2: ' + document.body.innerHTML;

                  var llog = teishi.last (B.log);
                  if (! eq ({verb: llog.verb, path: llog.path, rid: llog.args [0].responder}, {verb: 'redraw', path: ['Data', 'view'], rid: B.B + 1})) return 'Invalid redraw log #1.';

                  // REMOVE CLASS

                  B.call (x, 'set', ['Data', 'view'], ['div']);

                  if (c ('#' + B.B + 1) !== DOMElement) return 'DOM element not recycled #3.';
                  if (c.get ('.hello').length !== 0) return 'Class not removed #3.';

                  if ([
                     '<div id="–≤1" path="Data:view"></div>',
                     // Compatibility: IE<=8 removes the quotes around id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #3: ' + document.body.innerHTML;

                  // ADD CLASS AGAIN

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': '–≤la'}]);
                  if (c.get ('.–≤la').length !== 1) return 'Class not added #4.';

                  if ([
                     '<div id="–≤1" path="Data:view" class="–≤la"></div>',
                     // Compatibility: IE10-11, FF<=48 put the class first
                     '<div class="–≤la" id="–≤1" path="Data:view"></div>',
                     // Compatibility: IE9 puts the class in the middle
                     '<div id="–≤1" class="–≤la" path="Data:view"></div>',
                     // Compatibility: IE<=8 removes the quotes around id & class and uppercases the tag name
                     '<DIV id=–≤1 class=–≤la path="Data:view"></DIV>',
                     // Compatibility: IE<=7 puts the class at the beginning
                     '<DIV class=–≤la id=–≤1 path="Data:view"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #4: ' + document.body.innerHTML;

                  // REMOVE CLASS WITH null

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': null}]);
                  if (c.get ('.–≤la').length !== 0) return 'Class not removed #5.';

                  if ([
                     '<div id="–≤1" path="Data:view"></div>',
                     // Compatibility: IE<=8 removes the quotes around id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #5: ' + document.body.innerHTML;

                  // ADD CLASS AGAIN AND REMOVE WITH ''

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': 'foo'}]);
                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': ''}]);
                  if (c.get ('.foo').length !== 0) return 'Class not removed #6.';

                  if ([
                     '<div id="–≤1" path="Data:view"></div>',
                     // Compatibility: IE<=8 removes the quotes around id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #6: ' + document.body.innerHTML;

                  // ADD CONTENT

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': 'foo'}, 'content']);
                  if (c.get ('.foo').length !== 1) return 'Class not added #7.';

                  if ([
                     '<div id="–≤1" path="Data:view" class="foo">content</div>',
                     // Compatibility: IE10-11, FF<=48 put the class first
                     '<div class="foo" id="–≤1" path="Data:view">content</div>',
                     // Compatibility: IE9 puts the class in the middle
                     '<div id="–≤1" class="foo" path="Data:view">content</div>',
                     // Compatibility: IE<=8 removes the quotes around id & class, puts the class in the middle and uppercases the tag name
                     '<DIV id=–≤1 class=foo path="Data:view">content</DIV>',
                     // Compatibility: IE<=7 changes the order of class
                     '<DIV class=foo id=–≤1 path="Data:view">content</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #7: ' + document.body.innerHTML;

                  // REMOVE CONTENT

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': 'foo'}]);

                  if ([
                     '<div id="–≤1" path="Data:view" class="foo"></div>',
                     // Compatibility: IE10-11, FF<=48 put the class first
                     '<div class="foo" id="–≤1" path="Data:view"></div>',
                     // Compatibility: IE9 puts the class in the middle
                     '<div id="–≤1" class="foo" path="Data:view"></div>',
                     // Compatibility: IE<=8 removes the quotes around id & class, puts the class in the middle and uppercases the tag name
                     '<DIV id=–≤1 class=foo path="Data:view"></DIV>',
                     // Compatibility: IE<=7 changes the order of class
                     '<DIV class=foo id=–≤1 path="Data:view"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #8: ' + document.body.innerHTML;

                  // ADD CONTENT, REMOVE CLASS

                  B.call (x, 'set', ['Data', 'view'], ['div', 'content']);

                  if (c ('#' + B.B + 1) !== DOMElement) return 'DOM element not recycled #9.';

                  if ([
                     '<div id="–≤1" path="Data:view">content</div>',
                     // Compatibility: IE<=8 removes the quotes around id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">content</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #9: ' + document.body.innerHTML;

                  // ADD MULTIPLE ATTRIBUTES

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': 'foo', style: 'color: red'}, 'content']);

                  if ([
                     '<div id="–≤1" path="Data:view" class="foo" style="color: red">content</div>',
                     // Compatibility: IE10-11 changes the order of attributes and adds a semicolon to the style
                     '<div class="foo" id="–≤1" style="color: red;" path="Data:view">content</div>',
                     // Compatibility: Edge<=18 changes the order of attributes
                     '<div class="foo" id="–≤1" style="color: red" path="Data:view">content</div>',
                     // Compatibility: FF<=48 puts the style first
                     '<div style="color: red" class="foo" id="–≤1" path="Data:view">content</div>',
                     // Compatibility: FF<=3.6 puts the style first and adds a semicolon to the style
                     '<div style="color: red;" class="foo" id="–≤1" path="Data:view">content</div>',
                     // Compatibility: IE9 puts the class in the middle and adds a semicolon to the style
                     '<div style="color: red;" id="–≤1" class="foo" path="Data:view">content</div>',
                     // Compatibility: IE8 puts the style first and uppercases the attribute names, puts the class in the middle, removes quotes from id & class and uppercases the tag name
                     '<DIV style="COLOR: red" id=–≤1 class=foo path="Data:view">content</DIV>',
                     // Compatibility: IE<=7 removes quotes from id & class and removes altogether the style element!
                     '<DIV class=foo id=–≤1 path="Data:view">content</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #10: ' + document.body.innerHTML;

                  // LITHBAG CONTENT

                  B.call (x, 'set', ['Data', 'view'], ['div', {'class': 'foo', style: 'color: red'}, ['A', ['B', ['C'], 'D'], 'E']]);

                  if ([
                     '<div id="–≤1" path="Data:view" class="foo" style="color: red">ABCDE</div>',
                     // Compatibility: IE10-11 changes the order of attributes and adds a semicolon to the style
                     '<div class="foo" id="–≤1" style="color: red;" path="Data:view">ABCDE</div>',
                     // Compatibility: Edge<=18 changes the order of attributes
                     '<div class="foo" id="–≤1" style="color: red" path="Data:view">ABCDE</div>',
                     // Compatibility: FF<=48 puts the style first
                     '<div style="color: red" class="foo" id="–≤1" path="Data:view">ABCDE</div>',
                     // Compatibility: FF<=3.6 puts the style first and adds a semicolon to the style
                     '<div style="color: red;" class="foo" id="–≤1" path="Data:view">ABCDE</div>',
                     // Compatibility: IE9 puts the class in the middle and adds a semicolon to the style
                     '<div style="color: red;" id="–≤1" class="foo" path="Data:view">ABCDE</div>',
                     // Compatibility: IE8 puts the style first and uppercases the attribute names, puts the class in the middle, removes quotes from id & class and uppercases the tag name
                     '<DIV style="COLOR: red" id=–≤1 class=foo path="Data:view">ABCDE</DIV>',
                     // Compatibility: IE<=7 removes quotes from id and removes altogether the style element!
                     '<DIV class=foo id=–≤1 path="Data:view">ABCDE</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #11: ' + document.body.innerHTML;

                  // REMOVE ALL ATTRIBUTES

                  B.call (x, 'set', ['Data', 'view'], ['div', ['A', ['B', ['C'], 'D'], 'E']]);

                  if (c ('#' + B.B + 1) !== DOMElement) return 'DOM element not recycled #12.';

                  if ([
                     '<div id="–≤1" path="Data:view">ABCDE</div>',
                     // Compatibility: IE<=8 removes quotes from id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">ABCDE</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #12: ' + document.body.innerHTML;

                  // ADD ATTRIBUTES THAT WILL BE IGNORED

                  if (c ('#' + B.B + 1) !== DOMElement) return 'DOM element not recycled #13.';

                  B.call (x, 'set', ['Data', 'view'], ['div', {PATH: 'bar'}, ['A', ['B', ['C'], 'D'], 'E']]);

                  if ([
                     '<div id="–≤1" path="Data:view">ABCDE</div>',
                     // Compatibility: IE<=8 removes quotes from id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">ABCDE</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #13: ' + document.body.innerHTML;

                  // SPECIAL CHARACTERS IN CONTENT #1

                  B.call (x, 'set', ['Data', 'view'], ['div', '&lt;`Me &amp; you too!`&gt;']);

                  if ([
                     '<div id="–≤1" path="Data:view">&amp;lt;`Me &amp;amp; you too!`&amp;gt;</div>',
                     // Compatibility: IE<=8 removes quotes from id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">&amp;lt;`Me &amp;amp; you too!`&amp;gt;</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #14: ' + document.body.innerHTML;

                  // SPECIAL CHARACTERS IN CONTENT #2

                  B.call (x, 'set', ['Data', 'view'], ['div', '"I have \'quotes\'!"']);

                  if ([
                     '<div id="–≤1" path="Data:view">"I have \'quotes\'!"</div>',
                     // Compatibility: IE<=8 removes quotes from id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">"I have \'quotes\'!"</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #15: ' + document.body.innerHTML;

                  // SPECIAL CHARACTERS IN CONTENT #3

                  B.call (x, 'set', ['Data', 'view'], ['div', '<`Me & you too!`>']);

                  if ([
                     '<div id="–≤1" path="Data:view">&lt;`Me &amp; you too!`&gt;</div>',
                     // Compatibility: IE<=8 removes quotes from id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">&lt;`Me &amp; you too!`&gt;</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #16: ' + document.body.innerHTML;

                  // SPECIAL CHARACTERS IN CONTENT #4

                  B.call (x, 'set', ['Data', 'view'], ['div', '<script>hack ()</' + 'script>']);

                  if ([
                     '<div id="–≤1" path="Data:view">&lt;script&gt;hack ()&lt;/script&gt;</div>',
                     // Compatibility: IE<=8 removes quotes from id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">&lt;script&gt;hack ()&lt;/script&gt;</DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #17: ' + document.body.innerHTML;

                  // LITERAL CONTENT

                  B.call (x, 'set', ['Data', 'view'], ['div', ['LITERAL', 'a&nbsp;b']]);

                  if ([
                     '<div id="–≤1" path="Data:view">a&nbsp;b</div>',
                     // Compatibility: Opera<=10.6 converts &nbsp; to character with code 160
                     '<div id="–≤1" path="Data:view">a' + String.fromCharCode (160) + 'b</div>',
                     // Compatibility: IE<=8 removes quotes from id and uppercases the tag name
                     '<DIV id=–≤1 path="Data:view">a&nbsp;b</DIV>',
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #18: ' + document.body.innerHTML;

                  // NESTED ELEMENT

                  B.call (x, 'set', ['Data', 'view'], ['div', dale.go (dale.times (3), function (v) {return ['p', v]})]);

                  if ([
                     '<div id="–≤1" path="Data:view"><p>1</p><p>2</p><p>3</p></div>',
                     // Compatibility: IE<=8 removes quotes from id, uppercases the tag name and adds \r\n
                     '<DIV id=–≤1 path="Data:view">\r\n<P>1</P>\r\n<P>2</P>\r\n<P>3</P></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #19: ' + document.body.innerHTML;

                  var ps = c ('p');

                  // REMOVE INTERNAL ELEMENT FROM THE MIDDLE (CONTENT CHANGE)

                  B.call (x, 'set', ['Data', 'view'], ['div', dale.go (dale.times (2), function (v) {return ['p', v === 1 ? 1 : 3]})]);

                  if ([
                     '<div id="–≤1" path="Data:view"><p>1</p><p>3</p></div>',
                     // Compatibility: IE<=8 removes quotes from id, uppercases the tag name and adds \r\n
                     '<DIV id=–≤1 path="Data:view">\r\n<P>1</P>\r\n<P>3</P></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #20: ' + document.body.innerHTML;

                  if (c ('p') [0] !== ps [0]) return 'First paragraph changed unnecessarily #20';
                  if (c ('p') [1] !== ps [1]) return 'Second paragraph changed unnecessarily #20';

                  // REMOVE INTERNAL ELEMENT FROM THE MIDDLE (ATTRIBUTE CHANGE)

                  B.call (x, 'set', ['Data', 'view'], ['div', dale.go (dale.times (3), function (v) {return ['p', {'class': v}]})]);

                  ps = c ('p');

                  B.call (x, 'set', ['Data', 'view'], ['div', dale.go (dale.times (2), function (v) {return ['p', {'class': v === 1 ? 1 : 3}]})]);

                  if ([
                     '<div id="–≤1" path="Data:view"><p class="1"></p><p class="3"></p></div>',
                     // Compatibility: IE<=8 removes quotes from id & class, uppercases the tag name and adds \r\n
                     '<DIV id=–≤1 path="Data:view">\r\n<P class=1></P>\r\n<P class=3></P></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #21: ' + document.body.innerHTML;

                  if (c ('p') [0] !== ps [0]) return 'First paragraph changed unnecessarily #21';
                  if (c ('p') [1] !== ps [2]) return 'Third paragraph changed unnecessarily #21';

                  // REPLACE OUTERMOST ELEMENT

                  B.call (x, 'set', ['Data', 'view'], ['section', dale.go (dale.times (2), function (v) {return ['p', {'class': v === 1 ? 1 : 3}]})]);

                  if ([
                     '<section id="–≤1" path="Data:view"><p class="1"></p><p class="3"></p></section>',
                     // Compatibility: FF<=48 changes the order of path & id
                     '<section path="Data:view" id="–≤1"><p class="1"></p><p class="3"></p></section>',
                     // Compatibility: IE<=8 removes quotes from id & class, uppercases the tag name and adds \r\n
                     '<section id=–≤1 path="Data:view">\r\n<P class=1></P>\r\n<P class=3></P></section>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #22: ' + document.body.innerHTML;

                  if (c ('p') [0] !== ps [0]) return 'First paragraph changed unnecessarily #22';
                  if (c ('p') [1] !== ps [2]) return 'Third paragraph changed unnecessarily #22';

                  // REPLACE OUTERMOST ELEMENT WITH OTHER ELEMENTS IN CONTAINER

                  B.internal.count = 1;

                  B.unmount ('body');
                  B.call (x, 'set', ['Data', 'view'], ['div']);
                  B.mount ('body', function () {
                     return ['div', [
                        ['b'],
                        B.view (['Data', 'view'], function (view) {
                           return view;
                        }),
                        ['em']
                     ]];
                  });

                  if ([
                     '<div><b></b><div id="–≤1" path="Data:view"></div><em></em></div>',
                     // Compatibility: IE<=8 removes quotes from id & class, uppercases the tag name and adds \r\n
                     '<DIV><B></B>\r\n<DIV id=–≤1 path="Data:view"></DIV><EM></EM></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #23: ' + document.body.innerHTML;

                  B.call (x, 'set', ['Data', 'view'], ['p']);
                  if ([
                     '<div><b></b><p id="–≤1" path="Data:view"></p><em></em></div>',
                     // Compatibility: FF<=48 changes the order of path & id
                     '<div><b></b><p path="Data:view" id="–≤1"></p><em></em></div>',
                     // Compatibility: IE<=8 removes quotes from id & class, uppercases the tag name and adds \r\n
                     '<DIV><B></B>\r\n<P id=–≤1 path="Data:view"></P><EM></EM></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted #24: ' + document.body.innerHTML;

                  // *** AVOID ONCLICK TRIGGERING LINK CLICK ON RECYCLED ELEMENT ***

                  B.internal.count = 1;

                  B.unmount ('body');
                  B.call (x, 'set', ['Data', 'view'], ['div']);
                  B.mount ('body', function () {
                     return B.view (['State', 'link'], function (link) {
                        if (! link) return ['a', {onclick: B.ev ('set', ['State', 'link'], true)}, 'Not so fast!'];
                        else        return ['a', {href: '#foo'}, 'Not so fast!'];
                     });
                  });
                  try {
                     c ('a') [0].click ();
                  }
                  // https://caniuse.com/mdn-api_htmlelement_click
                  // This test won't be executed on Chrome < 19 and Firefox < 5 because there's no support for `click`ing an anchor programatically.
                  catch (error) {
                  }
                  if (window.location.hash === '#foo') return 'href was followed because of recycled element.';
                  B.call (x, 'rem', 'State', 'link');
               });

               Test ('B.view valid inputs, paths', function () {

                  // INITIAL SETUP

                  B.unmount ('body');

                  B.call (x, 'set', ['Data', 'view'], ['div']);

                  B.mount ('body', function () {
                     return B.view (['Data', 'view'], function (view) {
                        return view;
                     });
                  });

                  var responder = B.responders [B.B + 2];
                  if (responder.verb !== 'change') return 'Invalid change #2.';
                  if (responder.path.length !== 0) return 'Invalid path #2.';
                  if (responder.priority !== -1) return 'Invalid priority #2.';
                  if (! eq (responder.elem, ['div', {id: B.B + 2, path: 'Data:view'}])) return 'Invalid elem #2.';
                  if (responder.children.length !== 0) return 'Invalid children #2.';

                  // VIEW THAT DEPENDS ON EVERYTHING

                  var draws = 0;

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view ([], function (allData) {
                        draws++;
                        return ['pre', JSON.stringify (allData)];
                     });
                  });

                  responder = B.responders [B.B + 3];
                  if (responder.path.length !== 0) return 'Invalid path #3.';
                  if (responder.priority !== -1) return 'Invalid priority #3.';
                  if (! eq (responder.elem, ['pre', {id: B.B + 3, path: ':'}, JSON.stringify (B.get ())])) return 'Invalid elem #3.';
                  if (responder.children.length !== 0) return 'Invalid children #3.';

                  if ([
                     '<pre id="–≤3" path=":">' + JSON.stringify (B.store) + '</pre>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<PRE id=–≤3 path=":">' + JSON.stringify (B.store) + '</PRE>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, view with path []: ' + document.body.innerHTML;

                  if (draws !== 1) return 'View with path [] drawn more than once.';
                  B.call (x, 'change', []);
                  if (draws !== 2) return 'View with path [] drawn more than once on path change.';
                  B.call (x, 'change', ['foo', 'bar']);
                  if (draws !== 3) return 'View with path [] not drawn once with deep object modified.';

                  // MULTIPLE PATHS

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view ([['Data'], ['State']], function (Data, State, third) {
                        draws++;
                        return ['div', [
                           ['textarea', JSON.stringify (Data)],
                           ['textarea', JSON.stringify (State)],
                           ['textarea', arguments.length]
                        ]];
                     });
                  });

                  responder = B.responders [B.B + 4];
                  if (responder.path.length !== 0) return 'Invalid path #4.';
                  if (responder.priority !== -1) return 'Invalid priority #4.';
                  if (responder.children.length !== 0) return 'Invalid children #4.';

                  if ([
                     '<div id="–≤4" path="Data, State">' + '<textarea>' + JSON.stringify (Data) + '</textarea><textarea>' + JSON.stringify (State) + '</textarea><textarea>2</textarea></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤4 path="Data, State">' + '<TEXTAREA>' + JSON.stringify (Data) + '</TEXTAREA><TEXTAREA>' + JSON.stringify (State) + '</TEXTAREA><TEXTAREA>2</TEXTAREA></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, view with multiple paths #1: ' + document.body.innerHTML;

                  if (draws !== 4) return 'View with multiple paths drawn more than once.';
                  B.call (x, 'change', ['bla']);
                  if (draws !== 4) return 'View with multiple paths drawn unnecessarily.';
                  B.call (x, 'change', []);
                  if (draws !== 5) return 'View with multiple paths drawn invalid amount of times when root object changes.';
                  B.call (x, 'change', 'Data');
                  if (draws !== 6) return 'View with multiple paths drawn invalid amount of times when first argument changes.';
                  B.call (x, 'change', 'State');
                  if (draws !== 7) return 'View with multiple paths drawn invalid amount of times when second argument changes.';

                  // SIMPLE PATH

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view ('Data', function (Data) {
                        return ['div', [
                           ['textarea', JSON.stringify (Data)],
                           ['textarea', arguments.length]
                        ]];
                     });
                  });

                  responder = B.responders [B.B + 5];
                  if (responder.path.length !== 0) return 'Invalid path #5.';
                  if (responder.priority !== -1) return 'Invalid priority #5.';
                  if (responder.children.length !== 0) return 'Invalid children #5.';

                  if ([
                     '<div id="–≤5" path="Data">' + '<textarea>' + JSON.stringify (Data) + '</textarea><textarea>1</textarea></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤5 path="Data">' + '<TEXTAREA>' + JSON.stringify (Data) + '</TEXTAREA><TEXTAREA>1</TEXTAREA></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, view with multiple paths #2: ' + document.body.innerHTML;
               });

               Test ('B.view, nested views', function () {

                  // DOUBLE NESTED

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['Data', 'view'], function (view) {
                        return ['div', [
                           view,
                           B.view ('State', function (State) {
                              return ['pre', JSON.stringify (State)];
                           })
                        ]];
                     });
                  });

                  if ([
                     '<div id="–≤6" path="Data:view"><div></div><pre id="–≤7" path="State">{}</pre></div>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<DIV id=–≤6 path="Data:view">\r\n<DIV></DIV><PRE id=–≤7 path="State">{}</PRE></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, double nested: ' + document.body.innerHTML;

                  responder = B.responders [B.B + 6];
                  if (responder.path.length !== 0) return 'Invalid path #6.';
                  if (responder.priority !== -1) return 'Invalid priority #6.';
                  if (! (eq (responder.children, [B.B + 7]))) return 'Invalid children #6.';

                  var responder2 = B.responders [B.B + 7];
                  if (responder2.parent !== B.B + 6) return 'Invalid parent #7.';
                  if (responder2.path.length !== 0) return 'Invalid path #7.';
                  if (responder2.priority !== -2) return 'Invalid priority #7.';
                  if (! (eq (responder2.children, []))) return 'Invalid children #7.';

                  // TRIPLE NESTED

                  var draws = {outer: 0, medium: 0, inner0: 0, inner1: 0};

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['Data', 'view'], function (view) {
                        draws.outer++;
                        return ['div', [
                           view,
                           B.view ('State', function (State) {
                              draws.medium++;
                              return ['div', [
                                 B.view ('Data', function () {
                                    draws.inner0++;
                                    return ['pre'];
                                 }),
                                 B.view (['Data', 'view'], function () {
                                    draws.inner1++;
                                    return ['pre'];
                                 })
                              ]];
                           })
                        ]];
                     });
                  });

                  if ([
                     '<div id="–≤8" path="Data:view"><div></div><div id="–≤9" path="State"><pre id="–≤10" path="Data"></pre><pre id="–≤11" path="Data:view"></pre></div></div>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<DIV id=–≤8 path="Data:view">\r\n<DIV></DIV>\r\n<DIV id=–≤9 path="State"><PRE id=–≤10 path="Data"></PRE><PRE id=–≤11 path="Data:view"></PRE></DIV></DIV>',
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, triple nested #1: ' + document.body.innerHTML;

                  responder = B.responders [B.B + 8];
                  if (responder.priority !== -1) return 'Invalid priority #8.';
                  if (! (eq (responder.children, [B.B + 9]))) return 'Invalid children #8.';

                  responder2 = B.responders [B.B + 9];
                  if (responder2.parent !== B.B + 8) return 'Invalid parent #9.';
                  if (responder2.priority !== -2) return 'Invalid priority #9.';
                  if (! (eq (responder2.children, [B.B + 10, B.B + 11]))) return 'Invalid children #9.';

                  var responder3 = B.responders [B.B + 10];
                  if (responder3.parent !== B.B + 9) return 'Invalid parent #10.';
                  if (responder3.priority !== -3) return 'Invalid priority #10.';
                  if (! (eq (responder3.children, []))) return 'Invalid children #10.';

                  var responder4 = B.responders [B.B + 11];
                  if (responder4.parent !== B.B + 9) return 'Invalid parent #11.';
                  if (responder4.priority !== -3) return 'Invalid priority #11.';
                  if (! (eq (responder4.children, []))) return 'Invalid children #11.';

                  if (! eq (draws, {outer: 1, medium: 1, inner0: 1, inner1: 1})) return 'Invalid draws count #1.';

                  B.call (x, 'set', ['Data', 'view'], ['section']);

                  if ([
                     '<div id="–≤8" path="Data:view"><section></section><div id="–≤12" path="State"><pre id="–≤13" path="Data"></pre><pre id="–≤14" path="Data:view"></pre></div></div>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<DIV id=–≤8 path="Data:view"><section></section>\r\n<DIV id=–≤12 path="State"><PRE id=–≤13 path="Data"></PRE><PRE id=–≤14 path="Data:view"></PRE></DIV></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, triple nested #2: ' + document.body.innerHTML;

                  if (! eq (draws, {outer: 2, medium: 2, inner0: 2, inner1: 2})) return 'Invalid draws count #1.';

                  if (B.responders [B.B + 9] !== undefined)  return 'Responder #9 not deleted.';
                  if (B.responders [B.B + 10] !== undefined) return 'Responder #10 not deleted.';
                  if (B.responders [B.B + 11] !== undefined) return 'Responder #11 not deleted.';

                  responder = B.responders [B.B + 8];
                  if (responder.priority !== -1) return 'Invalid priority #8, 2.';
                  if (! (eq (responder.children, [B.B + 12]))) return 'Invalid children #8, 2.';

                  responder2 = B.responders [B.B + 12];
                  if (responder2.parent !== B.B + 8) return 'Invalid parent #12.';
                  if (responder2.priority !== -2) return 'Invalid priority #12.';
                  if (! (eq (responder2.children, [B.B + 13, B.B + 14]))) return 'Invalid children #12.';

                  responder3 = B.responders [B.B + 13];
                  if (responder3.parent !== B.B + 12) return 'Invalid parent #13.';
                  if (responder3.priority !== -3) return 'Invalid priority #13.';
                  if (! (eq (responder3.children, []))) return 'Invalid children #13.';

                  responder4 = B.responders [B.B + 14];
                  if (responder4.parent !== B.B + 12) return 'Invalid parent #14.';
                  if (responder4.priority !== -3) return 'Invalid priority #14.';
                  if (! (eq (responder4.children, []))) return 'Invalid children #14.';

               });

               Test ('B.view, tables', function () {

                  B.unmount ('body');
                  B.call (x, 'set', ['Data', 'view'], ['table']);
                  B.mount ('body', function () {
                     return B.view (['Data', 'view'], function (view) {
                        return view;
                     });
                  });

                  if ([
                     '<table id="–≤15" path="Data:view"></table>',
                     // Compatibility: IE8 uppercases the tag and removes the quotes around id
                     '<TABLE id=–≤15 path="Data:view"></TABLE>',
                     // Compatibility: IE<=7 uppercases the tag, adds a tbody and removes the quotes around id
                     '<TABLE id=–≤15 path="Data:view">\r\n<TBODY></TBODY></TABLE>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, table #1: ' + document.body.innerHTML;

                  B.call (x, 'set', ['Data', 'view'], ['table', ['tr']]);
                  if ([
                     '<table id="–≤15" path="Data:view"><tbody><tr></tr></tbody></table>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<TABLE id=–≤15 path="Data:view">\r\n<TBODY>\r\n<TR></TR></TBODY></TABLE>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, table #2: ' + document.body.innerHTML;

                  B.call (x, 'set', ['Data', 'view'], ['table', ['thead', ['tr']]]);
                  if ([
                     '<table id="–≤15" path="Data:view"><thead><tr></tr></thead></table>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<TABLE id=–≤15 path="Data:view">\r\n<THEAD>\r\n<TR></TR></THEAD></TABLE>',
                     // Compatibility: IE<=7 uppercases the tag, removes the quotes around id, adds \r\n and adds a TBODY
                     '<TABLE id=–≤15 path="Data:view">\r\n<THEAD>\r\n<TR></TR></THEAD>\r\n<TBODY></TBODY></TABLE>',
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, table #3: ' + document.body.innerHTML;

                  B.call (x, 'set', ['Data', 'view'], ['table', [['thead', ['tr']], [['tbody', ['tr']]]]]);
                  if ([
                     '<table id="–≤15" path="Data:view"><thead><tr></tr></thead><tbody><tr></tr></tbody></table>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<TABLE id=–≤15 path="Data:view">\r\n<THEAD>\r\n<TR></TR></THEAD>\r\n<TBODY>\r\n<TR></TR></TBODY></TABLE>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, table #4: ' + document.body.innerHTML;

                  B.call (x, 'set', ['Data', 'view'], ['table', ['thead', [['tr'], ['tr']]]]);
                  if ([
                     '<table id="–≤15" path="Data:view"><thead><tr></tr><tr></tr></thead></table>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<TABLE id=–≤15 path="Data:view">\r\n<THEAD>\r\n<TR></TR>\r\n<TR></TR></THEAD></TABLE>',
                     // Compatibility: IE<=7 uppercases the tag, removes the quotes around id, adds \r\n and adds a TBODY
                     '<TABLE id=–≤15 path="Data:view">\r\n<THEAD>\r\n<TR></TR>\r\n<TR></TR></THEAD>\r\n<TBODY></TBODY></TABLE>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, table #5: ' + document.body.innerHTML;

               });

               Test ('B.view, list', function () {
                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['Data', 'list'], function (list) {
                        return ['ul', dale.go (list, function (item) {
                           return ['li', item];
                        })];
                     });
                  });

                  if ([
                     '<ul id="–≤16" path="Data:list"></ul>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<UL id=–≤16 path="Data:list"></UL>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, list #1: ' + document.body.innerHTML;

                  B.call (x, 'set', ['Data', 'list'], [1, 2, 3, 4]);

                  if ([
                     '<ul id="–≤16" path="Data:list"><li>1</li><li>2</li><li>3</li><li>4</li></ul>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<UL id=–≤16 path="Data:list">\r\n<LI>1</LI>\r\n<LI>2</LI>\r\n<LI>3</LI>\r\n<LI>4</LI></UL>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, list #2: ' + document.body.innerHTML;

                  B.call (x, 'set', ['Data', 'list', 1], 9);

                  if ([
                     '<ul id="–≤16" path="Data:list"><li>1</li><li>9</li><li>3</li><li>4</li></ul>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<UL id=–≤16 path="Data:list">\r\n<LI>1</LI>\r\n<LI>9</LI>\r\n<LI>3</LI>\r\n<LI>4</LI></UL>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, list #3: ' + document.body.innerHTML;

                  B.call (x, 'rem', ['Data', 'list'], 2);

                  if ([
                     '<ul id="–≤16" path="Data:list"><li>1</li><li>9</li><li>4</li></ul>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<UL id=–≤16 path="Data:list">\r\n<LI>1</LI>\r\n<LI>9</LI>\r\n<LI>4</LI></UL>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, list #4: ' + document.body.innerHTML;

                  B.call (x, 'add', ['Data', 'list'], 'a > b');

                  if ([
                     '<ul id="–≤16" path="Data:list"><li>1</li><li>9</li><li>4</li><li>a &gt; b</li></ul>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and adds \r\n
                     '<UL id=–≤16 path="Data:list">\r\n<LI>1</LI>\r\n<LI>9</LI>\r\n<LI>4</LI>\r\n<LI>a &gt; b</LI></UL>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid HTML mounted, list #5: ' + document.body.innerHTML;

               });

               Test ('B.view, inputs', function () {
                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['Data'], function (Data) {
                        return ['div', [
                           Data.extra ? [
                              ['input', {value: 'throw focus off'}],
                              ['input', {value: 'throw focus off'}],
                              ['input', {value: 'throw focus off'}],
                           ] : [],
                           ['input', {id: 'user', value: B.get ('Data', 'user'),                   onchange: B.ev ('set', ['Data', 'user'])}],
                           ['input', {id: 'pass', value: B.get ('Data', 'pass'), type: 'password', onchange: B.ev ('set', ['Data', 'pass'])}]
                        ]];
                     });
                  });

                  c ('#user').focus ? c ('#user').focus () : c ('#user').setActive ();

                  B.call (x, 'set', ['Data', 'user'], 'hello!');
                  B.call (x, 'set', ['Data', 'pass'], 'secreto');

                  B.call (x, 'set', ['Data', 'extra'], true);

                  Test ('Focus & value tests', function () {
                     if (document.activeElement !== c ('#user')) return 'focus wasn\'t preserved when it should.';

                     if (c ('#user').value !== 'hello!')  return 'value wasn\'t preserved when it should: ' + c ('#user').value;
                     if (c ('#pass').value !== 'secreto') return 'value wasn\'t preserved when it should: ' + c ('#pass').value;
                  });

                  B.unmount ('body');

                  // This test checks that values are indeed overridden when inputs change,
                  // not just when the store is updated.
                  // This corner case has been found through the 7GUIs Celsius/Fahrenheit example
                  // and simplified further here for automatic testing.

                  B.mount ('body', function () {
                     return ['div', [
                        B.view (['Data', 'c'], function (c) {
                           return ['input', {value: c, onchange: B.ev ('set', ['Data', 'c'])}];
                        }),
                        B.view (['Data', 'f'], function (f) {
                           return ['input', {value: f, onchange: B.ev ('set', ['Data', 'f'])}];
                        })
                     ]];
                  });
                  var cresponder = B.respond ('change', ['Data', /c|f/], function (x, value) {
                     if (x.path [1] === 'c') B.call (x, 'set', ['Data', 'f'], parseInt (value) * 2);
                     if (x.path [1] === 'f') B.call (x, 'set', ['Data', 'c'], parseInt (value) / 2);
                  });

                  // Compatibility: we skip this tests in IE<=7 since its onchange event is buggy.
                  if (! B.internal.olderIE) {
                     c ('input') [0].value = 1;
                     c.fire (c ('input') [0], 'change');
                     if (c ('input') [1].value !== '2') return 'Invalid input value #1.';
                     c ('input') [1].value = 4;
                     c.fire (c ('input') [1], 'change');
                     if (c ('input') [0].value !== '2') return 'Invalid input value #2.';
                  }

                  B.unmount ('body');
                  B.forget (cresponder);

                  B.mount ('body', function () {
                     return B.view (['Data', 'quantity'], function (quantity) {
                        return ['div', ['input', {value: quantity}]];
                     });
                  });

                  B.call (x, 'set', ['Data', 'quantity'], 'abc');
                  if (c ('input') [0].value !== 'abc') return 'Invalid input value #3.';
                  B.call (x, 'rem', 'Data', 'quantity');
                  if (c ('input') [0].value !== '') return 'Invalid input value #4.';
                  B.unmount ('body');

                  // We preserve the id for this test to avoid modifying the ids on all the following tests.
                  B.internal.count = B.internal.count - 3;
               });

               Test ('B.view, textareas', function () {
                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['State', 'textarea'], function (data) {
                        return ['div', dale.go (data, function (v) {
                           return ['textarea', v === 6 ? undefined : '<' + v + '&'];
                        })];
                     });
                  });

                  if ([
                     '<div id="–≤18" path="State:textarea"></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤18 path="State:textarea"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Textareas #1: ' + document.body.innerHTML;

                  B.call (x, 'set', ['State', 'textarea'], [1, 2, 3, 4, 5]);
                  c ('textarea') [2].focus ? c ('textarea') [2].focus () : c ('textarea') [2].setActive ();
                  // Compatibility: IE<=8 requires a timeout to set an element as active, so we skip checking this to not complicate the tests.
                  var ie8 = document.activeElement === document.body;

                  if ([
                     '<div id="–≤18" path="State:textarea"><textarea>&lt;' + State.textarea.join ('&amp;</textarea><textarea>&lt;') + '&amp;</textarea></div>',
                     // Compatibility: Safari 4 doesn't escape text nodes inside textareas
                     '<div id="–≤18" path="State:textarea"><textarea><' + State.textarea.join ('&</textarea><textarea><') + '&</textarea></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤18 path="State:textarea"><TEXTAREA>&lt;' + State.textarea.join ('&amp;</TEXTAREA><TEXTAREA>&lt;') + '&amp;</TEXTAREA></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Textareas #2: ' + document.body.innerHTML;

                  B.call (x, 'set', ['State', 'textarea'], [5, 4, 1, 2, 3]);
                  if (! ie8 && document.activeElement !== c ('textarea') [2]) return 'Textarea lost focus #1.';
                  if ([
                     '<div id="–≤18" path="State:textarea"><textarea>&lt;' + State.textarea.join ('&amp;</textarea><textarea>&lt;') + '&amp;</textarea></div>',
                     // Compatibility: Safari 4 doesn't escape text nodes inside textareas
                     '<div id="–≤18" path="State:textarea"><textarea><' + State.textarea.join ('&</textarea><textarea><') + '&</textarea></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤18 path="State:textarea"><TEXTAREA>&lt;' + State.textarea.join ('&amp;</TEXTAREA><TEXTAREA>&lt;') + '&amp;</TEXTAREA></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Textareas #3: ' + document.body.innerHTML;

                  B.call (x, 'set', ['State', 'textarea'], [2, 1, 4, 3, 5]);
                  // Here the diff will move the 2nd textarea to the 4th position through recycling.
                  if (! ie8 && document.activeElement !== c ('textarea') [4]) return 'Textarea lost focus #2.';
                  if ([
                     '<div id="–≤18" path="State:textarea"><textarea>&lt;' + State.textarea.join ('&amp;</textarea><textarea>&lt;') + '&amp;</textarea></div>',
                     // Compatibility: Safari 4 doesn't escape text nodes inside textareas
                     '<div id="–≤18" path="State:textarea"><textarea><' + State.textarea.join ('&</textarea><textarea><') + '&</textarea></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤18 path="State:textarea"><TEXTAREA>&lt;' + State.textarea.join ('&amp;</TEXTAREA><TEXTAREA>&lt;') + '&amp;</TEXTAREA></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Textareas #4: ' + document.body.innerHTML;

                  B.call (x, 'set', ['State', 'textarea'], [1, 2, 5, 3, 4]);
                  if (! ie8 && document.activeElement !== c ('textarea') [4]) return 'Textarea lost focus #3.';
                  if ([
                     '<div id="–≤18" path="State:textarea"><textarea>&lt;' + State.textarea.join ('&amp;</textarea><textarea>&lt;') + '&amp;</textarea></div>',
                     // Compatibility: Safari 4 doesn't escape text nodes inside textareas
                     '<div id="–≤18" path="State:textarea"><textarea><' + State.textarea.join ('&</textarea><textarea><') + '&</textarea></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤18 path="State:textarea"><TEXTAREA>&lt;' + State.textarea.join ('&amp;</TEXTAREA><TEXTAREA>&lt;') + '&amp;</TEXTAREA></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Textareas #5: ' + document.body.innerHTML;

                  B.call (x, 'set', ['State', 'textarea'], [1, 2, 5, 3, 6]);
                  if (! ie8 && document.activeElement !== c ('textarea') [4]) return 'Textarea lost focus #4.';
                  if ([
                     '<div id="–≤18" path="State:textarea"><textarea>&lt;' + State.textarea.slice (0, 4).join ('&amp;</textarea><textarea>&lt;') + '&amp;</textarea><textarea></textarea></div>',
                     // Compatibility: Safari 4 doesn't escape text nodes inside textareas
                     '<div id="–≤18" path="State:textarea"><textarea><' + State.textarea.slice (0, 4).join ('&</textarea><textarea><') + '&</textarea><textarea></textarea></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤18 path="State:textarea"><TEXTAREA>&lt;' + State.textarea.slice (0, 4).join ('&amp;</TEXTAREA><TEXTAREA>&lt;') + '&amp;</TEXTAREA><TEXTAREA></TEXTAREA></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Textareas #6: ' + document.body.innerHTML;

               });

               Test ('B.view, selects', function () {

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['State', 'select'], function (both) {
                        return ['div', ! both ? [
                           ['select', [
                              ['option', {selected: null}, 1],
                              ['option', {selected: true}, 2],
                              ['option', {selected: ''}, 3]
                           ]]
                        ] : [
                           ['select', [
                              ['option', 1],
                              ['option', 2],
                              ['option', 3]
                           ]],
                           ['select', [
                              ['option', 1],
                              ['option', {selected: true}, 2],
                              ['option', 3]
                           ]]
                        ]];
                     });
                  });

                  if ([
                     '<div id="–≤19" path="State:select"><select><option>1</option><option selected="true">2</option><option>3</option></select></div>',
                     // Compatibility: IE<=8 uppercases the tag, removes the quotes around id and changes the selected attribute
                     '<DIV id=–≤19 path="State:select"><SELECT><OPTION>1</OPTION><OPTION selected>2</OPTION><OPTION>3</OPTION></SELECT></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Selects #1: ' + document.body.innerHTML;

                  if (c ('option') [1].selected !== true) return 'Option values not set #1.';

                  B.call (x, 'set', ['State', 'select'], true);

                  if ([
                     '<div id="–≤19" path="State:select"><select><option>1</option><option>2</option><option>3</option></select><select><option>1</option><option selected="true">2</option><option>3</option></select></div>',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes around id
                     '<DIV id=–≤19 path="State:select"><SELECT><OPTION>1</OPTION><OPTION>2</OPTION><OPTION>3</OPTION></SELECT><SELECT><OPTION>1</OPTION><OPTION selected>2</OPTION><OPTION>3</OPTION></SELECT></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) {
                     return 'Selects #2: ' + document.body.innerHTML;
                  }
                  if (c ('option') [4].selected !== true) return 'Option values not set #2.';

               });

               Test ('B.view, checkboxes', function () {

                  B.call (x, 'set', ['Data', 'items'], [
                     {id: 'widget1', title: 'Widget #1', price: 5,  checked: false},
                     {id: 'widget2', title: 'Widget #2', price: 8,  checked: true},
                     {id: 'widget3', title: 'Widget #3', price: 11, checked: true},
                     {id: 'widget4', title: 'Widget #4', price: 4,  checked: false}
                  ]);

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view ('Data', function (Data) {
                        return ['table', dale.go (Data.items, function (item, k) {
                           if (Data.filter && item.title.match (Data.filter) === null) return;
                           return ['tr', dale.go (['id', 'title', 'price', 'checked'], function (key) {
                              if (key === 'checked') return ['td', [
                                 ['input', {type: 'checkbox', checked: B.get ('Data', 'items', k, 'checked'), onchange: B.ev ('set', ['Data', 'items', k, 'checked'], ! B.get ('Data', 'items', k, 'checked'))}]
                              ]];
                              return ['td', item [key]];
                           })];
                        })];
                     });
                  });

                  if (c ('input') [0].checked !== false) return 'wrong checkbox was checked #1.';
                  if (c ('input') [3].checked !== false) return 'wrong checkbox was checked #2.';
                  if (c ('input') [1].checked !== true)  return 'checkbox wasn\'t checked #1.';
                  if (c ('input') [2].checked !== true)  return 'checkbox wasn\'t checked #2.';

                  B.call (x, 'set', ['Data', 'filter'], '1');
                  if (c ('input') [0].checked !== false) return 'wrong checkbox was checked #3.';

                  B.call (x, 'set', ['Data', 'filter'], '2');
                  if (c ('input') [0].checked !== true) return 'checkbox wasn\'t checked #3.';

                  B.call (x, 'set', ['Data', 'filter'], '');
                  if (c ('input') [0].checked !== false) return 'wrong checkbox was checked #4.';
                  if (c ('input') [3].checked !== false) return 'wrong checkbox was checked #5.';
                  if (c ('input') [1].checked !== true)  return 'checkbox wasn\'t checked #4.';
                  if (c ('input') [2].checked !== true)  return 'checkbox wasn\'t checked #5.';

                  // For some reason, dispatching `click` doesn't work, even on the newest browsers!
                  c.fire (c ('input') [0], 'change');

                  // Compatibility: firing the change event doesn't work on IE<=7, so we skip the check.
                  if (c ('input') [0].checked !== true && ! B.internal.olderIE) return 'checkbox not checked after event.';

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['Data', 'checkboxes'], function (checkboxes) {
                        return ['div', dale.go (checkboxes, function (v, k) {
                           return ['input', {type: 'checkbox', checked: v, onclick: B.ev ('set', ['Data', 'checkboxes', k], ! v)}];
                        })];
                     });
                  });
                  B.call (x, 'set', ['Data', 'checkboxes'], [false, false]);
                  if (c ('input') [0].checked !== false) return 'checkbox test #2 - checkbox #1 should not be checked';
                  if (c ('input') [1].checked !== false) return 'checkbox test #2 - checkbox #2 should not be checked';

                  c ('input') [0].click ();

                  // Compatibility: in IE<=7, clicking on the input doesn't seem to trigger the onclick handler.
                  if (B.internal.olderIE) B.call (x, 'set', ['Data', 'checkboxes', 0], true);

                  if (c ('input') [0].checked !== true) return 'checkbox test #2 - checkbox #1 should be checked after click';
                  if (B.get ('Data', 'checkboxes', 0) !== true) return 'checkbox test #2 - clicking on checkbox did not update store values';
                  B.call (x, 'set', ['Data', 'checkboxes'], [false, true]);
                  if (c ('input') [0].checked !== false) return 'checkbox #1 should not be checked after change in data';
                  B.call (x, 'set', ['Data', 'checkboxes'], [true, true]);
                  if (c ('input') [0].checked !== true) return 'checkbox #1 should not be checked after second change in data';

                  // We preserve the id for this test to avoid modifying the ids on all the following tests.
                  B.internal.count = B.internal.count - 1;
               });

               Test ('B.view, style', function () {

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view (['Data', 'margin'], function (margin) {
                        return ['div', [
                           ['style', ['div', {margin: margin || 0}]]
                        ]];
                     });
                  });

                  if ([
                     '<div id="–≤21" path="Data:margin"><style>div{margin:0;}</style></div>',
                     // IE<=8 removes the quotes around id, uppercases the tag and removes the <style> altogether!
                     '<DIV id=–≤21 path="Data:margin"></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Invalid style #1 ' + document.body.innerHTML;

                  // Because IE<=8 gets rid of the <style> altogether, we cannot expect gotoB to redraw things properly, so we skip this test.
                  if (! B.internal.oldIE) {
                     B.call (x, 'set', ['Data', 'margin'], 2);

                     if ([
                        '<div id="–≤21" path="Data:margin"><style>div{margin:2px;}</style></div>',
                        // IE<=8 removes the quotes around id, uppercases the tag and removes the <style> altogether!
                        '<DIV id=–≤21 path="Data:margin"></DIV>'
                     ].indexOf (document.body.innerHTML) === -1) return 'Invalid style #2 ' + document.body.innerHTML;
                  }

                  // We preserve the id for this test to avoid modifying the ids on all the following tests.
                  B.internal.count = B.internal.count - 1;
               });

               Test ('B.view, events', function () {
                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view ('Data', function (Data) {
                        return ['div', [
                           ['input', {id: 'i1', value: B.get ('Data', 'i1'), onchange: B.ev ('set', ['Data', 'i1'])}],
                           ['form', {id: 'i2'}, [
                              ['input', {id: 'user', type: 'text', value: B.get ('Data', 'i2', 'user'), onchange: B.ev ('set', ['Data', 'i2', 'user'])}],
                              Data.i8 ? [] : ['input'],
                              Data.i7 ? [] : ['input', {id: 'i7'}],
                              ['input', {id: 'pass', type: 'password', value: B.get ('Data', 'i2', 'pass'), onchange: B.ev ('set', ['Data', 'i2', 'pass'])}],
                              ['input', {id: 'button', type: 'button', value: 'Submit', onclick: B.ev ('upload', 'i2', '"a"', ',"b"')}]
                           ]],
                           ['textarea', {id: 'i3', onchange: B.ev ('set', ['Data', 'i3'])}, B.get ('Data', 'i3')],
                           ['form', {id: 'i4'}, [
                              ['label', 'Fries'],
                              ['input', {
                                 type: 'checkbox',
                                 checked: B.get ('Data', 'i4', 'fries'),
                                 onchange: B.ev ('set', ['Data', 'i4', 'fries'], ! B.get ('Data', 'i4', 'fries'))
                              }]
                           ]],
                           ['form', {id: 'i5'}, dale.go (['red', 'green', 'blue'], function (v) {
                              return [
                                 ['label', v],
                                 ['input', {name: 'colors', type: 'radio', checked: B.get ('Data', 'i5') === v, onchange: B.ev ('set', ['Data', 'i5'], v)}]
                              ];
                           })],
                           ['br'],
                           // Compatibility: Firefox<=3 requires autocomplete=off to update the values of select elements.
                           // https://stackoverflow.com/questions/1479233/why-doesnt-firefox-show-the-correct-default-select-option#comment42017501_1505693
                           // Compatibility: Chrome<=28 and Safari<=8 sometimes require to set the value of the select so that the correct option is selected, otherwise the first option is marked as selected even though there's another option that's selected.
                           ['select', {autocomplete: B.internal.oldFF ? 'off' : undefined, value: B.get ('Data', 'i6'), onchange: B.ev ('set', ['Data', 'i6'])}, dale.go (['select one', 'leisure', 'ok computer', 'second coming'], function (v) {
                              return ['option', {selected: B.get ('Data', 'i6') === v ? true : false, value: v}, v];
                           })]
                        ]];
                     });
                  });

                  c.set ('#i1', {value: 'i1'});
                  if (Data.i1 !== 'i1') return 'input onchange didn\'t update properly.';
                  B.call (x, 'set', ['Data', 'i1'], 'i1plus');
                  if (c.get ('#i1', 'value').value !== 'i1plus') return 'input wasn\'t refreshed properly.';


                  c.set ('#user', {value: 'Talk about'});
                  c.set ('#pass', {value: 'thepassion'});

                  if (! eq (B.get ('Data', 'i2'), {user: 'Talk about', pass: 'thepassion'})) return 'updated inputs didn\'t refresh the state: ' + JSON.stringify (B.get ('Data', 'i2'));

                  var matched = false, upload = B.respond ('upload', 'i2', {burn: true}, function (x, arg1, arg2) {
                     if (arg1 !== '"a"' || arg2 !== ',"b"') matched = null;
                     matched = true;
                  });

                  c.fire ('#button', 'click');
                  if (matched === false) return 'event wasn\'t triggered on click.';
                  if (matched === null)  return 'event didn\'t receive proper arguments.';

                  B.call (x, 'set', ['Data', 'i3'], 'some text');
                  // Compatibility: Firefox<=3 doesn't return the value of a textarea.
                  if (B.internal.oldFF) {
                     if (c ('#i3').innerHTML !== 'some text') return 'textarea wasn\'t set properly.';
                  }
                  else {
                     if (c ('#i3').value !== 'some text') return 'textarea wasn\'t set properly.';
                  }

                  B.call (x, 'set', ['Data', 'i4', 'fries'], true);
                  // Compatibility: we use selectors of the form {form: ..., selector: ...} for FF3 & IE<=8
                  if (c ({from: c ('#i4'), selector: 'input'}) [0].checked !== true) return 'checkbox wasn\'t checked.';

                  c.fire ({from: c ('#i4'), selector: 'input'}, 'change');
                  // Compatibility: firing the change event doesn't work on IE<=7, so we skip the check.
                  if (! B.internal.olderIE) {
                     if (B.get ('Data', 'i4', 'fries') !== false) return 'checkbox didn\'t change data after being changed.';
                     if (c ({from: c ('#i4'), selector: 'input'}) [0].checked !== false) return 'checkbox wasn\'t unchecked.';
                  }

                  B.call (x, 'set', ['Data', 'i5'], 'green');
                  if (c ({from: c ('#i5'), selector: 'input'}) [1].checked !== true) return 'radio wasn\'t selected.';

                  B.call (x, 'set', ['Data', 'i6'], 'ok computer');

                  if (c ('option') [2].selected !== true)       return 'select wasn\'t updated after data change 1.';

                  if (c ('select') [0].value !== 'ok computer') return 'select wasn\'t updated after data change 2.';

                  c ('#i7').focus ();

                  B.call (x, 'set', ['Data', 'i8'], true);

                  if (document.activeElement !== c ('#i7')) return 'focus wasn\'t preserved when it should.';

                  B.call (x, 'set', ['Data', 'i7'], true);

                  // Compatibility: IE<=11 don't set back the focus to body when the focused element is removed
                  // Compatibility: IE<=8 set the focus to document.documentElement when the focused element is removed
                  if ([null, document.body, document.documentElement].indexOf (document.activeElement) === -1) return 'focus was preserved when it shouldn\'t.';

               });

               Test ('B.view, trample', function () {
                  B.unmount ('body');
                  B.mount ('body', function () {
                     return ['div', [
                        ['p', 'hello'],
                        B.view (['Data', 'items'], function (items) {
                           return ['ul', dale.go (items, function (v) {return ['li', v]})];
                        })
                     ]];
                  });

                  B.internal.timeout = 1;
                  B.call (x, 'set', ['Data', 'items'], dale.times (100));
                  if ([
                     '<div><p>hello</p><ul id="–≤22" path="Data:items"><li>' + Data.items.join ('</li><li>') + '</li></ul></div>',
                     // IE<=8 removes the quotes around id, uppercases the tag and adds \r\n
                     '<DIV>\r\n<P>hello</P>\r\n<UL id=–≤22 path="Data:items">\r\n<LI>' + Data.items.join ('</LI>\r\n<LI>') + '</LI></UL></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Trample #1: ' + document.body.innerHTML;
                  var llog = teishi.last (B.log);
                  if (llog.args [0].diff !== false) return 'Trample #1 timeout was ignored.';

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return ['div', [
                        ['p', 'hello'],
                        B.view (['Data', 'items'], function (items) {
                           return [items.length === 100 ? 'ul' : 'div', dale.go (items, function (v) {return [items.length === 100 ? 'li' : 'p', v]})];
                        })
                     ]];
                  });

                  B.call (x, 'add', ['Data', 'items'], 0);
                  if ([
                     '<div><p>hello</p><div id="–≤23" path="Data:items"><p>' + Data.items.join ('</p><p>') + '</p></div></div>',
                     // IE<=8 removes the quotes around id, uppercases the tag and adds \r\n
                     '<DIV>\r\n<P>hello</P>\r\n<DIV id=–≤23 path="Data:items">\r\n<P>' + Data.items.join ('</P>\r\n<P>') + '</P></DIV></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Trample #2: ' + document.body.innerHTML;
                  llog = teishi.last (B.log);
                  if (llog.args [0].diff !== false) return 'Trample #2 timeout was ignored.';

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return ['div', [
                        ['p', 'hello'],
                        B.view (['Data', 'items'], function (items) {
                           return [items.length === 100 ? 'ul' : 'div', dale.go (items, function (v) {return [items.length === 100 ? 'li' : 'p', v]})];
                        }),
                        ['footer']
                     ]];
                  });

                  B.call (x, 'rem', ['Data', 'items'], 0);

                  if ([
                     '<div><p>hello</p><ul id="–≤24" path="Data:items"><li>' + Data.items.join ('</li><li>') + '</li></ul><footer></footer></div>',
                     // IE<=8 removes the quotes around id, uppercases the tag and adds \r\n
                     '<DIV>\r\n<P>hello</P>\r\n<UL id=–≤24 path="Data:items">\r\n<LI>' + Data.items.join ('</LI>\r\n<LI>') + '</LI></UL><FOOTER></FOOTER></DIV>'
                  ].indexOf (document.body.innerHTML) === -1) return 'Trample #3: ' + document.body.innerHTML;
                  llog = teishi.last (B.log);
                  if (llog.args [0].diff !== false) return 'Trample #3 timeout was ignored.';

                  B.internal.timeout = 200;

               });

               Test ('B.view, opaque', function () {
                  B.unmount ('body');
                  B.mount ('body', function () {
                     return B.view ('State', function (State) {
                        return ['section', [
                           ['table', dale.go (dale.times (State.ltable || 0), function (v) {
                              return ['tr', dale.go (dale.times (State.ltable || 0), function (v2, k2) {
                                 if (k2 === 0) return ['td', {'class': 'something ' + State.opaqueclass, opaque: true}, ['input']];
                                 else return ['td', k2];
                              })];
                           })],
                           ['div', {id: 'd1', opaque: true}],
                           ['div', {id: 'd2', opaque: true}, State.ltable],
                           ['div', {id: 'd3', opaque: true}, [
                              ['span'],
                              ['span'],
                           ]],
                           // Compatibility: IE<=8 doesn't support SVG
                           ['div', {id: 'd4', opaque: true}, ['LITERAL', ! B.internal.oldIE ? '<svg class="c' + State.ltable + '"></svg>' : '<div id="a' + State.ltable + '"></div>']]
                        ]];
                     });
                  });

                  B.call (x, 'set', ['State', 'ltable'], 2);

                  var opaques = c ('.something');
                  if (opaques.length !== 2) return 'Opaques were not created.';
                  opaques = c ('input');
                  if (opaques.length !== 2) return 'Opaque contents were not created.';
                  if ([
                     '<svg class="c2"></svg>',
                     // Compatibility: IE<=11 modifies the SVG
                     '<svg xmlns="http://www.w3.org/2000/svg" class="c2" />',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes of id
                     '<DIV id=a2></DIV>'
                  ].indexOf (c ('#d4').innerHTML) === -1) return 'Opaque with literal svg has invalid content #1: ' + c ('#d4').innerHTML;

                  c.fill ('.something', '<input><input>');
                  B.call (x, 'set', ['State', 'ltable'], 4);
                  opaques = c ('.something');
                  if (opaques.length !== 4) return 'Opaques were not updated #1.';
                  opaques = c ('input');
                  if (opaques.length !== 4) return 'Opaque contents were not updated #1.';
                  if ([
                     '<svg class="c4"></svg>',
                     // Compatibility: IE<=11 modifies the SVG
                     '<svg xmlns="http://www.w3.org/2000/svg" class="c4" />',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes of id
                     '<DIV id=a4></DIV>'
                  ].indexOf (c ('#d4').innerHTML) === -1) return 'Opaque with literal svg has invalid content #2: ' + c ('#d4').innerHTML;

                  c.fill ('.something', 'boo');
                  if (c ('.something') [0].innerHTML !== 'boo') return 'Opaque contents were not updated.';
                  opaques = c ('input');
                  if (opaques.length !== 0) return 'Opaque contents were not overwritten.';

                  B.call (x, 'set', ['State', 'ltable'], 5);
                  opaques = c ('.something');
                  if (opaques.length !== 5) return 'Opaques were not updated #2.';
                  opaques = c ('input');
                  if (opaques.length !== 5) return 'Opaque contents were not updated #2.';
                  if ([
                     '<svg class="c5"></svg>',
                     // Compatibility: IE<=11 modifies the SVG
                     '<svg xmlns="http://www.w3.org/2000/svg" class="c5" />',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes of id
                     '<DIV id=a5></DIV>'
                  ].indexOf (c ('#d4').innerHTML) === -1) return 'Opaque with literal svg has invalid content #3: ' + c ('#d4').innerHTML;

                  c.fill ('.something', '<div><input><span></span></div>');

                  B.call (x, 'set', ['State', 'ltable'], 4);
                  B.call (x, 'set', ['State', 'opaqueclass'], 'style');

                  opaques = c ('.style');
                  if (opaques.length !== 4) return 'Opaques were not updated #3.';
                  opaques = c ('input');
                  if (opaques.length !== 4) return 'Opaque contents were not updated #3.';

                  if (c ('#d1').innerHTML !== '') return 'Opaque empty has invalid content after redraw.';
                  if (c ('#d2').innerHTML !== '4') return 'Opaque text has invalid content after redraw.';
                  if ([
                     '<span></span><span></span>',
                     // Compatibility: IE<=8 uppercases the tag
                     '<SPAN></SPAN><SPAN></SPAN>'
                  ].indexOf (c ('#d3').innerHTML) === -1) return 'Opaque multiple has invalid content after redraw.';

                  if ([
                     '<svg class="c4"></svg>',
                     // Compatibility: IE<=11 modifies the SVG
                     '<svg xmlns="http://www.w3.org/2000/svg" class="c4" />',
                     // Compatibility: IE<=8 uppercases the tag and removes the quotes of id
                     '<DIV id=a4></DIV>'
                  ].indexOf (c ('#d4').innerHTML) === -1) return 'Opaque with literal svg has invalid content #4: ' + c ('#d4').innerHTML;

               });

               Test ('B.view, simultaneous redraws', function () {

                  B.unmount ('body');
                  B.mount ('body', function () {
                     return ['div', [
                        B.view (['State', 'list'], function (list) {
                           return ['table', dale.go (list, function (item) {
                              return ['tr', ['td', item]];
                           })];
                        }),
                        ['button', {onclick: B.ev (['add', ['State', 'list'], Math.random ()], ['add', ['State', 'list'], Math.random ()])}, 'Hit me']
                     ]];
                  });

                  c.fire ('button', 'click');

                  B.unmount ('body');

                  // I haven't yet found a way to trigger a queued redraw. gotoB's redraw mechanism is synchronous. Setting timeouts just before triggering a long redraw only pushes the execution of the timeout further.
                  // I have however seen a trigger for a redraw happening *before* the end of another redraw in applications where a DOM element (usually an input) has more than one event handler (for example, both "oninput" and "onchange"). In that case, the queuing mechanism of B.redraw kicks in to perform redraws on a first come, first serve basis. I haven't yet found a way to trigger such a situation programatically. Until I do, I leave this stub as a placeholder for a future test.

               });

               B.call (x, 'test', 'performance');

            });

            // *** PERFORMANCE ***

            B.respond ('test', 'performance', {burn: true}, function (x) {

               var data = dale.go (dale.times (40), function (v) {
                  return dale.go (dale.times (5), function (v2) {
                     return v2;
                  });
               });

               Time ['1: tests'] = time () - dale.acc (Time, function (a, b) {return a + b});

               B.unmount ('body');
               B.mount ('body', function () {
                  return B.view (['Data', 'perf'], function (perf) {
                     if (! perf) return ['table'];
                     return ['table', {style: 'display: block'}, dale.go (perf.data, function (v, k) {
                        return ['tr', dale.go (v, function (v2) {
                           return ['td', {"class": perf ['class']}, k + '-' + v2];
                        })];
                     })];
                  });
               });

               Time ['2: set view'] = time () - dale.acc (Time, function (a, b) {return a + b});

               B.call (x, 'set', ['Data', 'perf', 'data'], data);
               Time ['3: set data'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('set data', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'set', ['Data', 'perf', 'data', 10, 2], 'something');
               Time ['4: update one item'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('update one', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'set', ['Data', 'perf', 'class'], 'aclass');
               Time ['5: update all items'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('update all', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'rem', ['Data', 'perf', 'data', 10], 2);
               Time ['6: remove one item'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('remove one', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'add', ['Data', 'perf', 'data', 10], 999);

               Time ['7: add an item'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('add an item', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.prod = true;
               B.unmount ('body');
               B.call (x, 'rem', 'Data', 'perf');

               B.mount ('body', function () {
                  return B.view (['Data', 'perf'], function (perf) {
                     if (! perf) return ['table'];
                     return ['table', {style: 'display: block'}, dale.go (perf.data, function (v, k) {
                        return ['tr', dale.go (v, function (v2) {
                           return ['td', {"class": perf ['class']}, k + '-' + v2];
                        })];
                     })];
                  });
               });

               Time ['8: set view (prod)'] = time () - dale.acc (Time, function (a, b) {return a + b});

               B.call (x, 'set', ['Data', 'perf'], {});
               B.call (x, 'set', ['Data', 'perf', 'data'], data);
               Time ['9: set data (prod)'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('set data prod', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'set', ['Data', 'perf', 'data', 10, 2], 'something');
               Time ['10: update one item (prod)'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('update one prod', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'set', ['Data', 'perf', 'class'], 'aclass');
               Time ['11: update all items (prod)'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('update all prod', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'rem', ['Data', 'perf', 'data', 10], 2);
               Time ['12: remove one item (prod)'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('remove one prod', last (B.log).args [0].ms, last (B.log).args [0].diff);

               B.call (x, 'add', ['Data', 'perf', 'data', 10], 999);
               Time ['13: add an item (prod)'] = time () - dale.acc (Time, function (a, b) {return a + b});
               clog ('add item prod', last (B.log).args [0].ms, last (B.log).args [0].diff);

               Time ['14: total time'] = dale.acc (dale.fil (Time, undefined, function (v, k) {
                  if (k !== 'zero') return v;
               }), function (a, b) {return a + b});

               delete Time.zero;

               B.unmount ('body');

               Test ('responder cleanup', function () {
                  if (! eq (dale.keys (B.responders).sort (), ['R16', 'add', 'error', 'madd', 'mrem', 'mset', 'rem', 'set'])) return 'Some responders were not cleaned up!';
               });

               B.call (x, 'test', 'done');
            });

            B.respond ('test', 'done', {burn: true}, function (x) {
               if (Errorlist.length === 0) return c.fill ('body', lith.g ([
                  ['b', 'All tests successful!'],
                  ['pre', JSON.stringify (Time, null, '   ')],
                  ['button', {onclick: 'B.eventlog ()'}, 'Show event log']
               ]));

               c.fill ('body', lith.g ([
                  ['h2', 'Errors found!'],
                  ['pre', teishi.str (Errorlist, null, '   ')],
                  ['button', {onclick: 'B.eventlog ()'}, 'Show event log']
               ]));
            });

         }) ();

      </script>
   </body>
</html>
